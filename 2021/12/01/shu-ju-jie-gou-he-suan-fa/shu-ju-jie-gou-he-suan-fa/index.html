<!DOCTYPE HTML>
<html lang="zh-cn">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="老王的博客">
    <meta name="description" content="数据结构和算法
都是来自力扣上的题，记录的目的是为了加强记忆，并且能够回顾做过的题。
数组位运算（异或运算）当题目要你求一列数中只出现一次的数，而其他数都出现了偶数次。
例题1：136.只出现一次的数字

这题就是典型的利用异或运算来进行求">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>老王的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="老王的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">老王的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">老王的博客</div>
        <div class="logo-desc">
            
            如果……只是如果哦，一年、一年、又一年……七月七日的雨不停地落下，阻隔两人的银河一直波涛汹涌……那么他们两人，是否仍然会继续思念彼此呢？
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2021-12-01
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    50.2k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>数据结构和算法</p>
<p>都是来自力扣上的题，记录的目的是为了加强记忆，并且能够回顾做过的题。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="位运算（异或运算）"><a href="#位运算（异或运算）" class="headerlink" title="位运算（异或运算）"></a>位运算（异或运算）</h3><p><strong>当题目要你求一列数中只出现一次的数，而其他数都出现了偶数次。</strong></p>
<h4 id="例题1：136-只出现一次的数字"><a href="#例题1：136-只出现一次的数字" class="headerlink" title="例题1：136.只出现一次的数字"></a>例题1：136.只出现一次的数字</h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210714214941362.png" alt="image-20210714214941362" style="zoom:80%;">

<p>这题就是典型的利用异或运算来进行求解唯一数的问题</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        //运行异或运算来进行线性查找唯一的数
        int num = 0;
        for(int i = 0; i &lt; nums.size(); i++){
            num ^= nums[i];
        }
        return num;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题2：78-子集"><a href="#例题2：78-子集" class="headerlink" title="例题2：78. 子集"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210812155336901.png" alt="image-20210812155336901" style="zoom:80%;">

<p>这题我看了一个老哥的思路很不错，我们可以遍历nums数组，每次把已经得到的子集加上这个数得到新的子集</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;vector&lt;int&gt;&gt; res;
        res.push_back({});
        for(int i = 0; i &lt; n; i++){
            int m = res.size();
            for(int j = 0; j &lt; m; j++){
                vector&lt;int&gt; ans = res[j];
                ans.push_back(nums[i]);
                res.push_back(ans);
            }       
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>官方给出的位运算也是很不错的思路，这里记录一下</p>
<p>子集总共有2^n个，所以我们可以用n位2进制数来表示状态，例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">nums = [1, 2, 3]
000 =&gt;{}  = 0
001 =&gt;{3} = 1
010 =&gt;{2} = 2
011 =&gt;{2,3} = 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; ans;
        int mark = 1 &lt;&lt; n;
        for(int i = 0; i &lt; mark; i++){
            ans.clear();
            for(int j = 0; j &lt; n; j++){
                if(i &amp; (1 &lt;&lt; j)){
                    ans.push_back(nums[j]);
                }
            }
            res.push_back(ans);
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题3：90-子集-II"><a href="#例题3：90-子集-II" class="headerlink" title="例题3：90. 子集 II"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210812160621618.png" alt="image-20210812160621618" style="zoom:80%;">

<p>这题和上一题的子集是一样的思路，不过就是这里需要去重，因为给的nums数组中有重复的数字，所以稍微有点改动</p>
<p>自己的思路就是记录上次加入的新的子集的个数，如果这次的nums和上次的相同，那么就只把上次新加入的子集后面加该数，以前的都不加</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; ans;
        res.push_back(ans);
        int left = 0, right = 1, len = 0;
        for(int i = 0; i &lt; n; i++){
            //记录上次生成的新序列的长度 len，如果下次nums相同，那么就从n - len开始
            //如果不同，那么就所欲的序列都加上nums[i]
            if(i != 0 &amp;&amp; (nums[i - 1] == nums[i]))
                left = res.size() - len;
            else
                left = 0;
            right = res.size();
            len = right - left;
            for(int j = left; j &lt; right; j++){
                ans = res[j];
                ans.push_back(nums[i]);
                res.push_back(ans);
            }
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>那么官方给的还有位运算来做，如下</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; ans;
        for(int mark = 0; mark &lt; (1 &lt;&lt; n); mark++){
            bool flag = false;
            ans.clear();
            for(int i = 0; i &lt; n; i++){
                if(mark &amp; (1 &lt;&lt; i)){
                    if(i != 0 &amp;&amp; (mark &gt;&gt; (i - 1) &amp; 1) == 0 &amp;&amp; nums[i] == nums[i -1]){
                        flag = true;
                        break;
                    }
                    ans.push_back(nums[i]);
                }
                   
            }
            if(!flag)
                res.push_back(ans);
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题4：405-数字转换为十六进制数"><a href="#例题4：405-数字转换为十六进制数" class="headerlink" title="例题4：405. 数字转换为十六进制数"></a>例题4：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">405. 数字转换为十六进制数</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211002144244115.png" alt="image-20211002144244115" style="zoom:80%;">

<p>国庆出题还是比较温柔的呀，不过我还是调试了一半天，看来对于位运算还是理解不太到位。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    string toHex(int num) {
        if(num == 0) return "0";
        string Hex = "";
        int sum = 0;
        for(int i = 0; i &lt; 32; i++){
            sum += ((num &amp; (1 &lt;&lt; i)) == 0 ? 0 : 1) * pow(2, i % 4);
            //cout&lt;&lt;i&lt;&lt;" "&lt;&lt;sum&lt;&lt;" "&lt;&lt;(num &amp; (1&lt;&lt;i))&lt;&lt;" "&lt;&lt;pow(2, i % 4)&lt;&lt;endl;
            if(i % 4 == 3){
                if(sum &lt;= 9){
                    Hex += '0' + sum;
                }
                else{
                    Hex += 'a' + (sum - 10);
                }
                sum = 0;
            }
        }
        string Hex_reverse = "";
        bool flag = true;
        for(int i = Hex.size() - 1; i &gt;= 0; i--){
            if(Hex[i] == '0' &amp;&amp; flag){
                continue;
            }
            else{
                Hex_reverse += Hex[i];
                flag = false;
            }
        }
        return Hex_reverse;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其实还可以简化很多的。下面是我看来其它大佬写的。不得不说还是有很大差距啊。</p>
<p>利用oxf来进行取低四位我就没想到，而且也没想到利用string来进行存储十六进制。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    string toHex(int num) {
        if(num == 0) return "0";
        string hex = "0123456789abcdef";
        string ans = "";
        //num不为零并且ans长度小于8
        while(num &amp;&amp; ans.size() &lt; 8){
            ans = hex[num &amp; 0xf] + ans;
            num &gt;&gt;= 4;
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题5：260-只出现一次的数字-III"><a href="#例题5：260-只出现一次的数字-III" class="headerlink" title="例题5：260. 只出现一次的数字 III"></a>例题5：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h4><img src="images/数据结构和算法/image-20211031141115085.png" alt="image-20211031141115085" style="zoom:80%;">

<p>使用异或遍历整个数组，然后再找到异或得到的值的最后一个二进制非0位，那么那只出现一次的两个数在这个位置肯定分别位0和1，所以我们就把这个数组分成了两类，分别异或就行。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {
        int nums1 = 0, nums2 = 0;
        int xor_1 = 0;
        int n = nums.size();
        for(int i = 0; i &lt; n; i++){
            xor_1 = xor_1 ^ nums[i];
        }
        /*
        	这里有个小窍门 x^(~x)得到的就是最后一个非0位
        	但是要处理溢出的可能性，因为x = INT_MIN时，取反就溢出了
        	所以要判断一下
        	int lsb = (xorsum == INT_MIN ? xorsum : xorsum &amp; (-xorsum));
        */
        int bit_1 = 1;
        while((xor_1 &amp; 1) == 0){
            xor_1 &gt;&gt;= 1;
            bit_1 &lt;&lt;= 1;
        }
        for(int i = 0; i &lt; n; i++){
            if((nums[i] &amp; bit_1) == 0) nums1 ^= nums[i];
            else nums2 ^= nums[i];
        }
        return {nums1, nums2};
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h3><p>差分数组比较适合那种需要对数组进行加减的情况</p>
<p>这里的题解写的很不错：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9L6lz0XDZ9gi-d_iPrSs8Q">https://mp.weixin.qq.com/s/9L6lz0XDZ9gi-d_iPrSs8Q</a></p>
<h4 id="例题1：1109-航班预订统计"><a href="#例题1：1109-航班预订统计" class="headerlink" title="例题1：1109. 航班预订统计"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210901112716940.png" alt="image-20210901112716940" style="zoom:80%;">

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; corpFlightBookings(vector&lt;vector&lt;int&gt;&gt;&amp; bookings, int n) {
        //对于这种频繁加减的可以用差分数组来解决
        vector&lt;int&gt; diff(n, 0);
        vector&lt;int&gt; nums(n, 0);
        for(auto&amp; book : bookings){
            int x = book[0] - 1;
            int y = book[1] - 1;
            int val = book[2];
            diff[x] += val;
            if(y + 1 &lt; n) diff[y + 1] -= val;
        }
        nums[0] = diff[0];
        for(int i = 1; i &lt; n; i++){
            nums[i] = nums[i - 1] + diff[i];
        }
        return nums;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="哈希表、摩尔投票法"><a href="#哈希表、摩尔投票法" class="headerlink" title="哈希表、摩尔投票法"></a>哈希表、摩尔投票法</h3><h4 id="例题1：169-多数元素"><a href="#例题1：169-多数元素" class="headerlink" title="例题1：169.多数元素"></a>例题1：169.多数元素</h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210714221414443.png" alt="image-20210714221414443" style="zoom:80%;">

<p>只采用哈希表计数的方法：实现了时间复杂度为线性的，但空间复杂度也为线性</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        int base = nums.size() &gt;&gt; 1;
        int num;
        map&lt;int,int&gt; hash;
        for(int i = 0; i &lt; nums.size(); i++){
            hash[nums[i]]++;
            if(hash[nums[i]] &gt; base){
                num = nums[i];
                break;
            }
        }
        return num;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面重点来了，这里使用了我第一次听说的摩尔投票法（可能用过，但第一次听说专属名词）</p>
<ol>
<li>选取一个候选人，然后进行投票</li>
<li>如果下一个人投的是这个人，那么就count + 1</li>
<li>如果下一个人投的不是这个人，那么就count - 1</li>
<li>如果count = 0，那么就换候选人，选择下一个人作为候选人，并且count 置为 1</li>
<li>继续上述操作</li>
</ol>
<p>这里是投票法的证明，我觉得写的是不错的：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/">多数元素 - 多数元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>下面是代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        int count = 1;
        int candidate = nums[0];
        for(int i = 1; i &lt; nums.size(); i++){
            if(nums[i] == candidate)
                count++;
            else {
                count--;
                if(count == 0){
                    candidate = nums[i + 1];
                }
            }
        }
        return candidate;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题2：229-求众数-II"><a href="#例题2：229-求众数-II" class="headerlink" title="例题2：229. 求众数 II"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211022125203646.png" alt="image-20211022125203646" style="zoom:80%;">

<p>来了来了，这题又是一道摩尔投票法的扩展。真没想到还能用摩尔投票进行解题。</p>
<p>因为是求出现次数**超过[n / 3]**的元素，所以这肯定是只有两个的，可以通过反证法进行证明，那么我们可以通过摩尔投票，选择两个候选人，当count为0时，换下一个；否则就进行加减操作。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) {
        //摩尔投票法
        vector&lt;int&gt;res;
        int candidate1 = 0;
        int candidate2 = 0;
        int count1 = 0;
        int count2 = 0;

        for(int num : nums){
            if(count1 &gt; 0 &amp;&amp; candidate1 == num){
                count1++;
            }
            else if(count2 &gt; 0 &amp;&amp; candidate2 == num){
                count2++;
            }
            else if(count1 == 0){
                candidate1 = num;
                count1++;
            }
            else if(count2 == 0){
                candidate2 = num;
                count2++;
            }
            else{
                count1--;
                count2--;
            }
        }
        int cnt1 = 0, cnt2 = 0;
        for(int num : nums){
            if(count1 &gt; 0 &amp;&amp; num == candidate1) cnt1++;
            if(count2 &gt; 0 &amp;&amp; num == candidate2) cnt2++;
        }
        if(count1 &gt; 0 &amp;&amp; cnt1 &gt; nums.size() / 3) res.push_back(candidate1);
        if(count2 &gt; 0 &amp;&amp; cnt2 &gt; nums.size() / 3) res.push_back(candidate2);
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="例题1：977-有序数组的平方"><a href="#例题1：977-有序数组的平方" class="headerlink" title="例题1：977.有序数组的平方"></a>例题1：977.有序数组的平方</h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210716220959263.png" alt="image-20210716220959263" style="zoom:80%;">

<p>这题可以利用题目中已经排序的这个条件选择双指针来进行解题</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; new_nums(nums.size());
        //采用双指针
        int count = nums.size() - 1;
        int left = 0;   //指向负数
        int right = nums.size() - 1;  //指向正数
        while(left &lt;= right){
            int m = nums[left];
            int n = nums[right];
            if(abs(m) &gt; n){
                new_nums[count--] = m * m;
                left++;
            }
            else{
                new_nums[count--] = n * n;
                right--;
            }
        }
        return new_nums;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题2：189-旋转数组"><a href="#例题2：189-旋转数组" class="headerlink" title="例题2：189. 旋转数组"></a>例题2：189. 旋转数组</h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210716221855025.png" alt="image-20210716221855025" style="zoom:80%;">

<p>方法一：我用了数学方法，利用（i+k）%   n的方法来进行移动，这里空间复杂度为O(n)，时间复杂度为O(n)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        int n = nums.size();
        vector&lt;int&gt; new_nums(n);
        for(int i = 0; i &lt; n; i++){
            new_nums[(i + k) % n] = nums[i];
        }
        nums = new_nums;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>方法二：三次反转实现整体右移。（利用了reverse函数）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">nums = "-----&gt;--&gt;"; k =3
result = "--&gt;-----&gt;";

reverse "-----&gt;--&gt;" we can get "&lt;--&lt;-----"
reverse "&lt;--" we can get "--&gt;&lt;-----"
reverse "&lt;-----" we can get "--&gt;-----&gt;"
this visualization help me figure it out :)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//reverse(first, last) =&gt; [first,last)  这里要注意
class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        k %= nums.size();
        reverse(nums.begin(), nums.end());
        reverse(nums.begin(), nums.begin() + k);
        reverse(nums.begin() + k, nums.end());
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里是在原来函数基础上进行反转，但不知道为什么占用空间和方法一相同。</p>
<p>方法三：环状替换  </p>
<p>这里有个很形象的题解<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-yuan-di-huan-wei-xiang-xi-tu-jie/">【旋转数组】原地换位，详细图解 - 旋转数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        int count = 0;
        int n = nums.size();
        for(int start = 0; count &lt; n; start++){
            int current = start;
            int pre = nums[start];
            do{
                int next = (current + k) % n;
                int temp = nums[next];
                nums[next] = pre;
                pre = temp;
                current = next;
                count++;
            }while(current != start);
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题3：283-移动零"><a href="#例题3：283-移动零" class="headerlink" title="例题3：283. 移动零"></a>例题3：283. 移动零</h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210718095336385.png" alt="image-20210718095336385style=&quot;zoom:80%;&quot;" style="zoom:80%;">

<p><strong>解题思路</strong>：</p>
<ol>
<li>定义两个指针，left 指向 0， right 指向 非零的数</li>
<li>每次循环先判断left是否指向零，right是否指向非零，并且还要保证right &gt;= left</li>
<li>然后每次就交换一下left和right的指向的值，然后再根据边界判断是否加一</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int left = 0;
        int right = left + 1;
        int n = nums.size();
        while(left &lt; n &amp;&amp; right &lt; n){
            if(nums[left] != 0){
                left++;
                continue;
            }
            //这里要保证 right &gt;= left
            if(nums[right] == 0||right &lt; left){
                right++;
                continue;
            }
            int temp = nums[left];
            nums[left++] = nums[right];
            nums[right] = temp;
            //right可能会超出边界，所以这里需要加个判断条件
            if(right &lt; n - 1)
                right++;
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面是我写的双指针思路，官方的更简练，确实更优雅一些</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int left = 0, right = 0;
        int n = nums.size();
        while(right &lt; n){
            if(nums[right]){
                swap(nums[left], nums[right]);
                left++;
            }
            right++;
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还有一种方法，不过就不是双指针了，但也很漂亮。</p>
<p><strong>还是说一下思路吧：</strong></p>
<ol>
<li>定义一个index表示将会插入的非零的位置</li>
<li>循环遍历nums，遇到非零的数就另nums[index] = 这个数，index++</li>
<li>所以遍历完之后，index就表示非零数的个数</li>
<li>所以最后就从index开始到n结束，补0就行了</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int index = 0;
        int n = nums.size();
        for(int&amp; num : nums){
            if(num){
                nums[index] = num;
                index++;
            }
        }
        for(int i = index; i &lt; n; i++){
            nums[i] = 0;
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题4：167-两数之和-II-输入有序数组"><a href="#例题4：167-两数之和-II-输入有序数组" class="headerlink" title="例题4：167. 两数之和 II - 输入有序数组"></a>例题4：167. 两数之和 II - 输入有序数组</h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210718102206924.png" alt="image-20210718102206924" style="zoom:80%;">

<p>这题因为是升序的，所以倒不是很难想到用双指针解题，这题不难，就直接上代码了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        int left = 0;
        int right = numbers.size() - 1;
        vector&lt;int&gt; Two;
        while(left &lt; right){
            int num = numbers[left] + numbers[right];
            if(num &lt; target){
                left++;
            }
            else if(num &gt; target){
                right--;
            }
            else{
                Two.push_back(left + 1);
                Two.push_back(right + 1);
                break;
            }
        }
        return Two;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题5：344-反转字符串"><a href="#例题5：344-反转字符串" class="headerlink" title="例题5：344. 反转字符串"></a>例题5：344. 反转字符串</h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210719171940268.png" alt="image-20210719171940268" style="zoom:80%;">

<p>这题就不多说了，很简单，直接上代码</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    void reverseString(vector&lt;char&gt;&amp; s) {
        int left = 0;
        int right = s.size() - 1;
        while(left &lt; right){
            int temp = s[left];
            s[left++] = s[right];
            s[right--] = temp;
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题6：557-反转字符串中的单词-III"><a href="#例题6：557-反转字符串中的单词-III" class="headerlink" title="例题6：557. 反转字符串中的单词 III"></a>例题6：557. 反转字符串中的单词 III</h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210719173639216.png" alt="image-20210719173639216" style="zoom:80%;">

<p>这题倒也不难，只不过相比于上一题要单独分析每个完整的字符串，所以这里需要思考一下。</p>
<p>需要着重思考的点有：</p>
<ul>
<li>边界</li>
<li>left和right如何取值</li>
<li>如何来确定单独的单词</li>
</ul>
<p>基本就这几个需要考虑的点</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution {
public:
    string reverseWords(string s) {
        int left ;
        int right;
        //这里使用了flag来标记一个单独的字符串反转完成
        int flag = 0;
        //cnt表示单独字符串的长度，方便于求left
        int cnt = 0;
        for(int i = 0; i &lt; s.size(); i++){
            if(s[i] == ' ' || i == s.size() - 1){
                left = i - cnt;
                //这里right需要注意一下边界
                if(i != s.size() - 1)
                    right = i - 1;
                else
                    right = i;
                while(left &lt; right){
                    int temp = s[left];
                    s[left++] = s[right];
                    s[right--] = temp;
                }
                flag = 1;
            }
            if(flag == 1){
                cnt = 0;
                flag = 0;
            }
            else
                cnt++;
        }
        return s;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题7：876-链表的中间结点"><a href="#例题7：876-链表的中间结点" class="headerlink" title="例题7：876. 链表的中间结点"></a>例题7：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210719214639201.png" alt="image-20210719214639201" style="zoom:80%;">

<p>这题是快慢指针问题，定义两个指针。满指针走一步，快指针走两步。</p>
<p>下面是我自己想出来的方法，速度感觉表示很快，但已经是O（n）的复杂度了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        //快慢指针问题
        ListNode* fast = head;
        ListNode* slow = head;
        while(true){
            if(fast-&gt;next == nullptr){
                break;
            }
            else if(fast-&gt;next-&gt;next == nullptr){
                slow = slow-&gt;next;
                break;
            }
            else{
                fast = fast-&gt;next-&gt;next;
                slow = slow-&gt;next;
            }
        }
        return slow;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个是看来评论后精简的代码：这里对于快指针处理的比较好。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast != nullptr &amp;&amp; fast-&gt;next != nullptr){
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        return slow;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题8：19-删除链表的倒数第-N-个结点"><a href="#例题8：19-删除链表的倒数第-N-个结点" class="headerlink" title="例题8：19. 删除链表的倒数第 N 个结点"></a>例题8：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210719221543614.png" alt="image-20210719221543614" style="zoom:80%;">

<p>这题也是相当于快慢指针问题，不过是一个指针在另一个指针前面n个，然后等速移动罢了</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //也是双指针问题，不过一个指针在另一个指针的前n个
        if(head-&gt;next == nullptr &amp;&amp; n == 1){
            head = nullptr;
            return head;
        }
        ListNode* front = head;
        ListNode* rear = head;
        for(int i = 0; i &lt; n; i++){
            rear = rear-&gt;next; 
        }
        while(rear != nullptr &amp;&amp; rear-&gt;next != nullptr){
            front = front-&gt;next;
            rear = rear-&gt;next;
        }
        //这里是防止front指针未移动，而rear指针就为null了
        //例如 [1,2], n = 2，这里front = head，而rear往后移动2个就为null，所以直接跳出循环，无法确定是为了删除头节点
        if(front == head &amp;&amp; rear == nullptr){
            ListNode* p = head;
            head = head-&gt;next;
            delete p;
            return head;
        }
        ListNode* p = front-&gt;next;
        front-&gt;next = p-&gt;next;
        delete p;
        return head;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题9：15-三数之和"><a href="#例题9：15-三数之和" class="headerlink" title="例题9：15. 三数之和"></a>例题9：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210731131125702.png" alt="image-20210731131125702" style="zoom:80%;">

<p>这题和以往的双指针题目不一样，这里算是三指针的题目了，不过也可以看成双指针，一个指针从头指向倒数第三个，然后还是左、右指针进行寻找相加等于0的点。</p>
<p>大致步骤：</p>
<ol>
<li>对于长度小于3的数组，直接返回</li>
<li>对数组进行排序</li>
<li>遍历排序后的数组<ol>
<li>如果num[i] &gt; 0，那么就不可能存在相加等于0的结果，所以直接返回</li>
<li>如果num[i] == num[i -1]，进入下一循环，避免重复元素</li>
<li>令left = i + 1，right = nums.size() - 1，执行循环：<ol>
<li>如果num[i] + num[left] + num[right] == 0，则满足条件，加入向量中，并执行循环。判断左边界和右边界是否与下一元素重复，去除重复值。最后移动边界。</li>
<li>如果相加小于0，那么左边界右移</li>
<li>如果相加大于0，那么右边界左移</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; numbers;
        if(nums.size() &lt; 3) return numbers;
        sort(nums.begin(), nums.end());
        for(int i = 0; i &lt; nums.size() - 2 &amp;&amp; nums[i] &lt;= 0; i++){
            //避免重复值
            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
            int left = i + 1;
            int right = nums.size() - 1;
            while(left &lt; right){
                int sum = nums[left] + nums[right];
                if(sum == -nums[i]){
                    vector&lt;int&gt; threeNums;
                    threeNums.push_back(nums[i]);
                    threeNums.push_back(nums[left]);
                    threeNums.push_back(nums[right]);
                    numbers.push_back(threeNums);
                    //去除重复值
                    while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;
                    while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;
                    //避免死循环
                    left++;
                    right--;           
                }
                else if(sum &lt; -nums[i]){
                    left++;
                }
                else{
                    right--;
                }
            }
        }
        return numbers;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题10：986-区间列表的交集"><a href="#例题10：986-区间列表的交集" class="headerlink" title="例题10：986. 区间列表的交集"></a>例题10：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/interval-list-intersections/">986. 区间列表的交集</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210805174407318.png" alt="image-20210805174407318" style="zoom:80%;">

<p>这道题目不是很难，利用双指针和这个区间的性质来进行解题</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; intervalIntersection(vector&lt;vector&lt;int&gt;&gt;&amp; firstList, vector&lt;vector&lt;int&gt;&gt;&amp; secondList) {
        int n_first = firstList.size();
        int n_second = secondList.size();
        int first = 0;
        int second = 0;
        vector&lt;vector&lt;int&gt;&gt; ans;
        if(n_first == 0 || n_second == 0) return ans;
        while(first &lt; n_first &amp;&amp; second &lt; n_second){
            int x1 = firstList[first][0];
            int y1 = firstList[first][1];
            int x2 = secondList[second][0];
            int y2 = secondList[second][1];
            if(max(x1, x2) &lt;= min(y1, y2)){
                ans.push_back({max(x1, x2), min(y1, y2)});
            }
            if(y1 &lt; y2){
                first++;
            }
            else{
                second++;
            }
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题11：11-盛最多水的容器"><a href="#例题11：11-盛最多水的容器" class="headerlink" title="例题11：11. 盛最多水的容器"></a>例题11：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210805182640910.png" alt="image-20210805182640910" style="zoom:80%;">

<p>这题不难想，两个指针分别指向最左侧和最右侧，然后因为不管是左指针向右移动1位还是右指针向左移动1位，底部边长都减少1，所以我们要保证高度较低的那个指针移动，以保证后续面积更大的可能性。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
        int left = 0;
        int right = height.size() - 1;
        int area = 0;
        while(left &lt; right){
            int min_height = min(height[left], height[right]);
            int new_area = (right - left) * min_height;
            area = max(area, new_area);
            if(height[left] &lt; height[right]) left++;
            else right--;
        }
        return area;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="例题1：34-在排序数组中查找元素的第一个和最后一个位置"><a href="#例题1：34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="例题1：34. 在排序数组中查找元素的第一个和最后一个位置"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210731141855683.png" alt="image-20210731141855683" style="zoom:80%;">

<p>这题就是分别用二分查找寻找左右边界，各用一次就行了。</p>
<ol>
<li>从右边逼近左边界</li>
<li>从左边逼近右边界</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; ans(2, -1);
        if(nums.empty()) return ans;
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        //从右逼近寻求左边界
        while(left &lt; right){
            int mid = left + (right - left) / 2;
            if(nums[mid] &gt;= target) right = mid;
            else left = mid + 1;
        }
        if(nums[left] != target) return ans;
        ans[0] = left;
        left = 0, right = n - 1;
        //从左逼近寻求右边界
        while(left &lt; right){
            //防止陷入死循环，因为left这里是特殊情况
            int mid = left + (right - left + 1) / 2;
            if(nums[mid] &lt;= target) left = mid;
            else right = mid - 1;
        }
        ans[1] = left;
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题2：33-搜索旋转排序数组"><a href="#例题2：33-搜索旋转排序数组" class="headerlink" title="例题2：33. 搜索旋转排序数组"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210801113909845.png" alt="image-20210801113909845" style="zoom:80%;">

<p>这题还是有些难度的，这里用两种方法来做。</p>
<p><strong>方法一：</strong>旋转数组中的目标值转换成有序数组中的目标值</p>
<ol>
<li>我们还是按照二分查找的模板来做；例如：4，5，6，7，0，1，2</li>
<li>如果目标值在左半边，那么就转换成4，5，6，7，inf，inf，inf</li>
<li>如果目标值在右半边，那么就转换成-inf，-inf，-inf，-inf，0，1，2</li>
<li>就这样把mid所在的元素转换成inf或-inf</li>
</ol>
<p><strong>代码如下：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int n = nums.size();
        int left =  0;
        int right = n - 1;
        while(left &lt;= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target){
                return mid;
            }
            //判断target在左半边还是右半边
            if(target &gt;= nums[0]){
                //判断mid在右半边还是左半边
                if(nums[mid] &lt; nums[0]){
                    nums[mid] = INT_MAX;
                }
            }
            else{
                //若mid在左半边，则改成MIN_INT
                if(nums[mid] &gt;= nums[0]){
                    nums[mid] = INT_MIN;
                }
            }
            if(nums[mid] &gt; target){
                right = mid - 1;
            }
            if(nums[mid] &lt; target){
                left = mid + 1;
            }
        }
        return - 1;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>方法二：</strong>直接对旋转数组进行二分查找（根据左右半边确定左右边界的值）</p>
<p>先根据num[mid]来判断mid是在左半边还是右半边，然后再根据target判断在mid的左边还是右边。根据上述来调整left和right的值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        while(left &lt;= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target){
                return mid;
            }
            //如果mid在左半边
            if(nums[mid] &gt;= nums[left]){
                //如果target在mid左边
                if(target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid]){
                    right = mid - 1;
                }
                else{
                    left = mid + 1;
                }
            }
            //如果mid在右半边
            else{
                //如果target在mid右边
                if(target &lt;= nums[right] &amp;&amp; target &gt; nums[mid]){
                    left = mid + 1;
                }
                else{
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题3-1：74-搜索二维矩阵"><a href="#例题3-1：74-搜索二维矩阵" class="headerlink" title="例题3_1：74. 搜索二维矩阵"></a>例题3_1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210801124457531.png" alt="image-20210801124457531" style="zoom:80%;">

<p>这题不是一个难题，还是二分查找，只不过换成了升序的二维数组罢了。</p>
<p><strong>代码如下</strong>：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        int n = matrix.size();
        int m = matrix[0].size();
        int left = 0;
        int right = n * m - 1;
        while(left &lt;= right){
            int mid = left + (right - left) / 2;
            int row = mid / m;
            int col = mid - m * row;
            if(matrix[row][col] == target){
                return true;
            }
            else if(matrix[row][col] &gt; target){
                right = mid - 1;
            }
            else{
                left = mid + 1;
            }
        }
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题3-2：240-搜索二维矩阵-II"><a href="#例题3-2：240-搜索二维矩阵-II" class="headerlink" title="例题3_2：240. 搜索二维矩阵 II"></a>例题3_2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211025130536918.png" alt="image-20211025130536918" style="zoom:80%;">

<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211025130521012.png" alt="image-20211025130521012" style="zoom:80%;">

<p>这是上道题的升级版，常规方法是遍历行，然后列用二分查找，时间复杂度为O(m+n)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        int n = matrix.size(), m = matrix[0].size();
        int left, right;
        for(int i = 0; i &lt; n &amp;&amp; matrix[i][0] &lt;= target; i++){
            if(matrix[i][0] == target) return true;
            left = 0, right = m - 1;
            while(left &lt;= right){
                int mid = left + (right - left) / 2;
                if(matrix[i][mid] &lt; target){
                    left = mid + 1;
                }
                else if(matrix[i][mid] &gt; target){
                    right = mid - 1;
                }
                else return true;
            }
        }
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是既然是升级版的题，那么当然也有升级版的解法。<strong>Z形查找</strong></p>
<p>我们可以从右上角即[0, m - 1]开始查找，如果当前位置为[x, y]，那么我们每次搜索矩阵左下角为左下角，该点为右上角的矩阵。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">matrix[x][y] == target : return true
matrix[x][y] &gt; target : 那么说明该列都大于target，所以 y - 1，取前一列为矩阵的最后一列
matrix[x][y] &lt; target : 那么说明该行都小于target，所以 x + 1，取下一行作为矩阵的第一行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>代码如下：</strong>时间复杂度为O(m + n)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        int n = matrix.size(), m = matrix[0].size();
        int x = 0, y = m - 1;
        while(x &lt; n &amp;&amp; y &gt;= 0){
            if(matrix[x][y] == target) return true;
            else if(matrix[x][y] &gt; target){
                y--;
            }
            else x++;
        }
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="例题4：153-寻找旋转排序数组中的最小值"><a href="#例题4：153-寻找旋转排序数组中的最小值" class="headerlink" title="例题4：153. 寻找旋转排序数组中的最小值"></a>例题4：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210801131321408.png" alt="image-20210801131321408" style="zoom:80%;">

<p>这题也是一个二分搜索题目，不过这里是要搜索最小值，我们可以每次取中间值与nums[0]进行比较，寻找第一个小于nums[0]的元素就行。</p>
<p><strong>代码如下：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        //即寻找第一个小于nums[0]的元素的下标
        while(left &lt;= right){
            int mid = left + (right - left) / 2;
            
            if(nums[mid] &gt;= nums[0]){
                left = mid + 1;
            }
            else{
                right = mid - 1;
            }
        }
        //如果下标大于等于n的话，说明1~n-1的元素都比nums[0]大，所以nums[0]就是最小的元素
        if(left &gt;= n) return nums[0];
        return nums[left];
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题5：162-寻找峰值"><a href="#例题5：162-寻找峰值" class="headerlink" title="例题5：162. 寻找峰值"></a>例题5：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210801134833630.png" alt="image-20210801134833630" style="zoom:80%;">

<p>看到这道题其实还没想到用二分查找，因为第一感觉不是有序的，但看到下面的要求复杂度尾logN时就知道可以用二分查找。</p>
<p>我们可以每次用中间值与两边进行比较，确定边界值，不过这里要注意数组越界的问题，我上了几次当了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        if(n == 1) return 0;
        int left = 0;
        int right = n - 1;
        while(left &lt;= right){
            int mid = left + (right - left) / 2;
            //防止越界
            if(mid &gt; 0 &amp;&amp; nums[mid] &lt; nums[mid - 1]){
                right = mid - 1;
            }
            //防止越界
            else if(mid &lt; n - 1 &amp;&amp; nums[mid] &lt; nums[mid + 1]){
                left = mid + 1;
            }
            else{
                return mid;
            }
        }
        return -1;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题6：29-两数相除"><a href="#例题6：29-两数相除" class="headerlink" title="例题6：29. 两数相除"></a>例题6：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/divide-two-integers/">29. 两数相除</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211012143312616.png" alt="image-20211012143312616" style="zoom:80%;">

<p>这题有几个需要注意的点，第一个就是边界条件，第二个是换成正数后会越界的问题。</p>
<p>我们可以把这两个数都换成负数X，Y，这样就不会越界。然后寻找一个Z，使Z * Y &gt;= X &gt;= (Z + 1)*Y，找到这个Z就行了，这个可以使用二分查找加快速幂（其实是快速加，不过思想是一样的）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int divide(int dividend, int divisor) {
        //如果被除数为INT_MIN
        if(dividend == INT_MIN){
            if(divisor == -1){
                return INT_MAX;
            }
            if(divisor == 1){
                return INT_MIN;
            }
        }
        //如果除数为INT_MIN
        if(divisor == INT_MIN){
            if(dividend == INT_MIN){
                return 1;
            }
            else{
                return 0;
            }
        }
        if(dividend == 0) return 0;
        //因为如果把数转化成正数进行比较会超出范围，所以变成负数比较就行了
        bool negative = false;
        if(dividend &gt; 0){
            dividend = -dividend;
            negative = !negative;
        }
        if(divisor &gt; 0){
            divisor = -divisor;
            negative = !negative;
        }
        int left = 1, right = INT_MAX;
        int ans = 0;
        while(left &lt;= right){
            int mid = left + (right - left) / 2;
            bool check = quickADD(divisor, mid, dividend);
            if(check){
                ans = mid;
                //这里要注意溢出，比如dividend = 2147483647，divisor = 1
                if(mid == INT_MAX) break;
                left = mid + 1;
            }
            else{
                right = mid - 1;
            }
        }
        return negative ? -ans : ans;
    }
    bool quickADD(int y, int z, int x){
        //x , y是负数，z是正数
        //判断z * y &gt;= x是否成立
        int result = 0, add = y;
        while(z){
            if(z &amp; 1){
                //保证 result + add &gt;= x
                if(result &lt; x - add) return false;
                result += add;
            }
            if(z != 1){
                //保证 add + add &gt;= x
                if(add &lt; x - add) return false;
                add += add;
            }
            z &gt;&gt;= 1;
        }
        return true;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题7：400-第-N-位数字"><a href="#例题7：400-第-N-位数字" class="headerlink" title="例题7：400. 第 N 位数字"></a>例题7：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nth-digit/">400. 第 N 位数字</a></h4><img src="images/数据结构和算法/image-20211130110642057.png" alt="image-20211130110642057" style="zoom:80%;">

<p>怎么说呢，这道题我第一次还是做不出来，考虑多了。感觉复杂一点的模拟题我就不太好写逻辑。我们应该要抓住主要步骤：</p>
<ol>
<li>先计算出第n个数字所在的整数的长度</li>
<li>计算出该整数</li>
<li>算出在该整数中的第几位</li>
<li>计算出该数字</li>
</ol>
<p>总的来说这题不算太难，但还是要逻辑清晰才能做出来。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int totalDigits(int length){
        int digits = 0;
        int curLength = 1, curCount = 9;
        while(curLength &lt;= length){
            digits += curLength * curCount;
            curLength++;
            curCount *= 10;
        }
        return digits;
    }
    int findNthDigit(int n) {
        int left = 1, right = 9;
        while(left &lt; right){
            int mid = (left + right) / 2;
            if(totalDigits(mid) &lt; n){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        //已经算出来了该整数的长度，现在算具体是那个整数
        int d = left;    //该整数的长度
        int preDigits = totalDigits(d - 1);
        int index = n - preDigits - 1;
        int start = pow(10, d - 1);
        //计算出该整数
        int num = start + index / d;
        //计算出n为改整数中的哪一位
        int digitIndex = index % d;
        int digit = (num / (int)(pow(10, d - digitIndex - 1))) % 10;
        return digit;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="最长非降子序列"><a href="#最长非降子序列" class="headerlink" title="最长非降子序列"></a>最长非降子序列</h3><h4 id="例题1：1964-找出到每个位置为止最长的有效障碍赛跑路线"><a href="#例题1：1964-找出到每个位置为止最长的有效障碍赛跑路线" class="headerlink" title="例题1：1964. 找出到每个位置为止最长的有效障碍赛跑路线"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-longest-valid-obstacle-course-at-each-position/">1964. 找出到每个位置为止最长的有效障碍赛跑路线</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210808135240610.png" alt="image-20210808135240610" style="zoom:80%;">

<p>这个题目就是求每个元素的最长非降子序列的长度的问题，我们可以维护一个单调栈，这个栈也是非降的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    const static int MAXN = 1e5 + 1;
    //top = 0， 表示里面还没有元素
    int Stack[MAXN], top = 0;
    vector&lt;int&gt; longestObstacleCourseAtEachPosition(vector&lt;int&gt;&amp; obstacles) {
        vector&lt;int&gt; res;
        for(int x : obstacles){
            //p表示单调栈中大于x的第一个元素的位置
            //+1是为了保证p为该非降子序列的长度
            int p = upper_bound(Stack + 1, Stack + top + 1, x) - Stack;
            res.push_back(p);
            //维护单调栈，保持非降
            Stack[p] = x;
            top = max(top, p);
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="堆（优先队列）"><a href="#堆（优先队列）" class="headerlink" title="堆（优先队列）"></a>堆（优先队列）</h3><h4 id="例题1：313-超级丑数"><a href="#例题1：313-超级丑数" class="headerlink" title="例题1：313. 超级丑数"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210809110808223.png" alt="image-20210809110808223" style="zoom:80%;">

<p>这题可以使用最小堆来实现，我们每次从堆中去除对顶元素（即最小子数），然后与primes中的元素相乘放入堆中，当然还要判断该丑数是否放如果，这里可以用哈希集合来记录。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) {
        //最小堆
        priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt;&gt; heap;
        unordered_set&lt;long&gt; visited;
        heap.push(1);
        visited.insert(1);
        int ugly = 1;
        while(n){
            long cur = heap.top();
            heap.pop();
            ugly = (int)cur;
            for(int prime : primes){
                long pro = prime * cur;
                if(visited.insert(pro).second){
                    heap.push(pro);
                }
            }
            n--;
        }
        return ugly;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>方法二：<strong>动态规划</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">例如 n = 10, primes = [2,3,5]  那么丑数列表为 1, 2, 3, 5, 4, 6, 8, 9, 10, 12<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​    观察列表可看出后面的丑数一定是前面的丑数乘以列表primes中的元素得到的。所以我们可以想丑数是递增的，那么我们该如何递增的去得到第n个字数呢？</p>
<p>​    观察上面的例子，1，2，3，4，5，6分别乘以2，3，5得到后面6 * 3 = 18个新丑数，也就是说1，2，3，4，5，6都分别有一次与2相乘的机会，一次与3相乘的机会和一次与5相乘的机会。所以我们可以<strong>创建三个指针</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pointer2, 指向1, 2, 3, 4, 5, 6中，还没使用乘2机会的丑数的位置。该指针的前一位已经使用完了乘以2的机会。
pointer3, 指向1, 2, 3, 4, 5, 6中，还没使用乘3机会的丑数的位置。该指针的前一位已经使用完了乘以3的机会。
pointer5, 指向1, 2, 3, 4, 5, 6中，还没使用乘5机会的丑数的位置。该指针的前一位已经使用完了乘以5的机会。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>​    下一次寻找丑数时就可以让每个指针所指的元素使用与2，3，5相乘的机会，然后把其中最小的丑数就是下一个丑数，这里也要注意对应的最小丑数的指针要加一，因为该机会已经用完了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) {
        //k指针问题。
        //dp[i]表示第i个丑数，pointers[i]表示dp[pointers[i]]之前的丑数已经用了乘以primes[i]的机会
        vector&lt;int&gt; dp(n + 1, 0);
        dp[1] = 1;
        int m = primes.size();
        //一开始都指向1，表示dp[1]都有乘以primes中元素的机会
        vector&lt;int&gt; pointers(m, 1);
        for(int i = 2; i &lt;= n; i++){
            vector&lt;int&gt; nums(m);
            int ans = INT_MAX;
            for(int j = 0; j &lt; m; j++){
                nums[j] = dp[pointers[j]] * primes[j];
                ans = min(ans, nums[j]);
            }
            dp[i] = ans;
            for(int k = 0; k &lt; m; k++){
                if(nums[k] == ans){
                    pointers[k]++;
                }
            }
        }
        return dp[n];
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题2：295-数据流的中位数"><a href="#例题2：295-数据流的中位数" class="headerlink" title="例题2：295. 数据流的中位数"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210827154657913.png" alt="image-20210827154657913" style="zoom:80%;">

<p>这题我们主要是要动态的插入数据并排序，可以用平衡二叉树，但是实现起来很麻烦，所以我们这里可以采用堆（优先队列）进行解题。</p>
<p>我们把数组分成两部分，这两部分是按顺序的，中位数就是左边最大的数或者左边最大的数和右边最小的数的和的平均值，而且我们要保证左边数的数量大于或等于右边。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MedianFinder {
public:
    //找到左边最大值，大顶堆，降序排列
    priority_queue&lt;int&gt; Max;
    //找到右边最小值,小顶堆，升序排列
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; Min;
    /** initialize your data structure here. */
    MedianFinder() {
    }
    //两个优先队列的长度不能超过1
    void addNum(int num) {
        Max.push(num);
        Min.push(Max.top());
        Max.pop();
        if(Max.size() &lt; Min.size()){
            Max.push(Min.top());
            Min.pop();
        }
    }
    double findMedian() {
        if(Max.size() == Min.size())
            return (Max.top() + Min.top()) / 2.0;
        else
            return Max.top();
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj-&gt;addNum(num);
 * double param_2 = obj-&gt;findMedian();
 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><h4 id="例题1：5853-从子集的和还原数组"><a href="#例题1：5853-从子集的和还原数组" class="headerlink" title="例题1：5853. 从子集的和还原数组"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-array-given-subset-sums/">5853. 从子集的和还原数组</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210823091823723.png" alt="image-20210823091823723" style="zoom:80%;">

<p>这题还是很难的，我也是看来别人好长时间才理解，太菜了。</p>
<p>我们可以找这个集合的最小值和次小值，最小值肯定是所有负数相加，那么次小值就是最小值加上一个最小的正数或者减去最大的负数，这样我们次小值 - 最小值就是得到了一个在集合中存在的数，但是正负号我们还不确定，所以分情况讨论正负号就行。</p>
<p>这样我们每次能确定一个数，规模由n 变为n - 1，而且sums变为不包含这个数的所有子集和的集合。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int MAXN = 1e5 + 50;
int used[MAXN];
class Solution {
public:
    vector&lt;int&gt; recoverArray(int n, vector&lt;int&gt;&amp; sums) {
        //找最小值和次小值
        int mi = min(sums[0], sums[1]), cmi = max(sums[0], sums[1]);
        if(n == 1){
            if(mi == 0) return {cmi};
            if(cmi == 0) return {mi};
            return {};
        }
        //最小值 - 次小值 = 一个真实的数，所以我们得找到sums的最小值和次小值
        int len = 1 &lt;&lt; n;
        for(int i = 2; i &lt; len; i++){
            int v = sums[i];
            if(sums[i] &lt; mi){
                cmi = mi;
                mi = v;
            }
            else{
                if(v &lt; cmi) cmi = v;
            }
        }
        int delta = cmi - mi;
        //接下来就是求这个真实值，分为正数和负数两种情况
        //用used数组来储存存在 delta 的情况和不存在 delta 的情况
        bool flag = true;
        for(int i = 0; i &lt; len; i++) used[i] = 0;
        sort(sums.begin(), sums.end());
        //positive正数的情况
        for(int i = 0, j = 0; i &lt; len &amp;&amp; flag; i++){
            if(used[i] != 0) continue;
            //表示这个子集不包含delta
            used[i] = 1;
            while(j &lt; len &amp;&amp; (sums[j] &lt; sums[i] + delta) || used[j] != 0) j++;
            if(j &lt; len &amp;&amp; sums[j] == sums[i] + delta)
                //表示这个子集情况包含delta
                used[j] = 2;
            else
                //表示没有一个数和sums[i]对应，所以delta不是正数，退出就行了
                flag = false;
        }
        if(flag){
            //把那些没有delta的情况加入到数组中，进行n - 1的递归
            vector&lt;int&gt; cur;
            for(int i = 0; i &lt; len; i++){
                if(used[i] == 1) cur.push_back(sums[i]);
            }
            vector&lt;int&gt; ret = recoverArray(n - 1, cur);
            if(ret.size() &gt; 0){
                //加入这个真实数
                ret.push_back(delta);
                return ret;
            }
        }

        //negative负数的情况
        for(int i = 0; i &lt; len; i++) used[i] = 0, sums[i] = -sums[i];
        flag = true;
        sort(sums.begin(), sums.end());
        for(int i = 0, j = 0; i &lt; len &amp;&amp; flag; i++){
            if(used[i] != 0) continue;
            used[i] = 1;
            while(j &lt; len &amp;&amp; (sums[j] &lt; sums[i] + delta || used[j] != 0)) j++;
            if(j &lt; len &amp;&amp; sums[j] == sums[i] + delta)
                used[j] = 2;
            else
                flag = false;
        }
        if(flag){
            vector&lt;int&gt; cur;
            for(int i = 0; i &lt; len; i++){
                if(used[i] == 1) cur.push_back(sums[i]);
            }
            vector&lt;int&gt; ret = recoverArray(n - 1, cur);
            vector&lt;int&gt; res;
            if(ret.size() &gt; 0){
                for(int v : ret) res.push_back(-v);
                res.push_back(-delta);
                return res;
            }
        }
        return {};
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个题我自己想是真的想不出来，主要很难有切入点，还是思维不够灵敏啊，很多细节也很难处理，不愧是hard题。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>这里先写一个模板吧，看的东哥的文章，写的很不错。<strong>有的题目可能会用不到need和valid，有的可能要加点东西。</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map&lt;char, int&gt; need, window;
    for (char c : t) need[c]++;

    int left = 0, right = 0;
    int valid = 0; 
    while (right &lt; s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="例题1：3-无重复字符的最长子串"><a href="#例题1：3-无重复字符的最长子串" class="headerlink" title="例题1：3. 无重复字符的最长子串"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210720201117736.png" alt="image-20210720201117736" style="zoom:80%;">

<p>这题可以用滑动窗口来进行解题，大体思路如下：</p>
<ol>
<li>这里因为是要求最长字串，且只需要长度不需要具体的字符串，所以只需要定义 ans 来记录长度就行，不需要start和len来记录字串起始位置长度</li>
<li>不需要need窗口，只需要window窗口</li>
<li>每次往window加入s[right]，如果没有重复的话，就记录长度，并于上一次的长度进行比较，取最大值</li>
<li>如果重复的话，就需要缩小窗口，知道刚才插入的数据没有重复，然乎在记录长度，并比较</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map&lt;char,int&gt; window;
        int left = 0;
        int right = 0;
        //记录长度
        int ans = 0;
        while(right &lt; s.size()){
            char c = s[right];
            right++;
            //加入窗口
            window[c]++;
            //缩小窗口，如果刚才加入的元素重复的话
            while(window[c] &gt; 1){
                //从最左侧开始缩小
                char d = s[left];
                left++;
                window[d]--;
            }
            ans = max(ans, right - left);
        } 
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题2：567-字符串的排列"><a href="#例题2：567-字符串的排列" class="headerlink" title="例题2：567. 字符串的排列"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210720204944162.png" alt="image-20210720204944162" style="zoom:80%;">

<p>这题也是滑动窗口类型的题目，说一下大体思路吧：</p>
<ol>
<li>这里就需要valid来记录满足的个数，只要个数与need中存在的元素的个数相等就表示已经满足了，可以开始缩小窗口了</li>
<li>我们还是先把s2[right]放入窗口中，直到valid等于need的元素的个数</li>
<li>开始缩小窗口，直到valid不等于need的元素个数，下面是缩小的具体思路</li>
<li>从left开始，先判断s2[left]是否在窗口中，如果在的话<ol>
<li>先判断此时是否满足窗口的长度等于s1的长度，满足的话就完成了要求，返回true</li>
<li>不满足的话，就看window[d]是否等于need[d]，这里是为了判断valid是否会减小</li>
</ol>
</li>
<li>然后window[left]–，最后在left++，这里其实也可以在前面就自增，但是为了判断是否满足条件那里好看就放后面了</li>
</ol>
<p>这差不多就是大体的思路了，滑动窗口类型的题目做的还不多，但思路已经有了</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        unordered_map&lt;char,int&gt; need, window;
        for(char c : s1)
            need[c]++;
        int left = 0;
        int right = 0;
        int valid = 0;
        bool flag = false;
        while(right &lt; s2.size()){
            char c = s2[right];
            right++;
            //加入窗口
            if(need.count(c)){
                window[c]++;
                if(window[c] == need[c])
                    valid++;
            }
            //缩小窗口，当已经获取的元素包含了所有的所需要的元素就可以缩小窗口
            while(valid == need.size()){
                int d = s2[left];
                if(window.count(d)){
                    if(right - left == s1.size()){
                        flag = true;
                        return flag;
                    }
                    if(window[d] == need[d]) valid--;
                    window[d]--;
                }
                left++;
            }
        }
        return flag;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题3：438-找到字符串中所有字母异位词"><a href="#例题3：438-找到字符串中所有字母异位词" class="headerlink" title="例题3：438. 找到字符串中所有字母异位词"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210805212748916.png" alt="image-20210805212748916" style="zoom:80%;">

<p>这题很明显是滑动窗口问题，当满足包含 p 字符串中所有字符这个条件时，就可以开始缩小窗口。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; findAnagrams(string s, string p) {
        unordered_map&lt;char, int&gt; window, need;
        //需要的字符
        for(char&amp; c : p) need[c]++;
        //左右指针
        int left = 0, right = 0;
        int valid = 0;
        vector&lt;int&gt; res;
        while(right &lt; s.size()){
            char c = s[right];
            right++;
            if(need.count(c)){
                window[c]++;
                if(window[c] == need[c]) valid++;
            }
            //达到要求，缩小窗口
            while(valid == need.size()){
                char d = s[left];
                if(need.count(d)){
                    //如果满足了p字符串中所有字符这个条件，就把left加入到vector向量中
                    if(right - left == p.size()) res.push_back(left);
                    if(window[d] == need[d]) valid--;
                    window[d]--;
                }
                //left在前面自增的话，判断满足条件那就要注意了
                left++;
            }
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题4：713-乘积小于K的子数组"><a href="#例题4：713-乘积小于K的子数组" class="headerlink" title="例题4：713. 乘积小于K的子数组"></a>例题4：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-product-less-than-k/">713. 乘积小于K的子数组</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210805230123412.png" alt="image-20210805230123412" style="zoom:80%;">

<p>这个题目不是典型的滑动窗口的题，但是用到了滑动窗口的思想，本题的关键是 r - l + 1，即要固定右边界来求子数组的个数，例如[2, 5, 4]是一个满足的数组，那么从右边开始数就是，[4]，[5, 4]， [2, 5, 4]，这样就不会因为移动左边界而重复的计数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) {
        if(k &lt;= 1) return 0;
        int left = 0, right = 0;
        int product = 1;
        int cnt = 0;
        while(right &lt; nums.size()){
            product = product * nums[right];
            while(product &gt;= k){
                product /= nums[left++];
            }
            cnt += right - left + 1;
            right++;
        }
        return cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题5：187-重复的DNA序列"><a href="#例题5：187-重复的DNA序列" class="headerlink" title="例题5：187. 重复的DNA序列"></a>例题5：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211008130222045.png" alt="image-20211008130222045" style="zoom:80%;">

<p>这题可以直接用哈希表存储长度为10的字符串，一边遍历，一边记录。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
    const int L = 10;
public:
    vector&lt;string&gt; findRepeatedDnaSequences(string s) {
        vector&lt;string&gt; ans;
        unordered_map&lt;string, int&gt; cnt;
        int n = s.length();
        for (int i = 0; i &lt;= n - L; ++i) {
            string sub = s.substr(i, L);
            if (++cnt[sub] == 2) {
                ans.push_back(sub);
            }
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度为O(nL)</p>
<p>这题还可以用位运算来做，因为就四个字符，所以我们可以使用两个比特来代表一个字符</p>
<blockquote>
<p>A 00</p>
<p>B 01</p>
<p>C 10</p>
<p>D 11</p>
</blockquote>
<p>这样长度为10的字符串也只占了20个比特，比int类型32比特少，所以完全行得通。</p>
<p>那么还有个问题就是每次移动一个字符，怎么来快速的计算这个字符串的值呢？——我们可以使用滑动窗口的思想</p>
<ol>
<li>我们先记录一个字符串的值，为 x</li>
<li>右边来个字符，我们就 x &lt;&lt; 2，左移两位，然后 x | bin(s[i])，表示这个字符的二进制。</li>
<li>这样左边也要出去一个字符，所以我们再x &amp; ((1 &lt;&lt; 2 * L) - 1)，只保留低20位，高位全置零</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
    const int L = 10;
    unordered_map&lt;char, int&gt; bin = {{'A', 0}, {'C', 1}, {'G', 2}, {'T', 3}};
public:
    vector&lt;string&gt; findRepeatedDnaSequences(string s) {
        int n = s.size();
        if(n &lt;= L) return {};
        vector&lt;string&gt; res;
        int x = 0;
        for(int i = 0; i &lt; L - 1; i++){
            x = (x &lt;&lt; 2) | bin[s[i]];
        }
        unordered_map&lt;int, int&gt; cnt;
        for(int i = 0; i &lt;= n - L; i++){
            x = ((x &lt;&lt; 2) | bin[s[i + L - 1]]) &amp; ((1 &lt;&lt; 2 * L) - 1);
            if(++cnt[x] == 2) res.push_back(s.substr(i, L));
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="例题1：516-最长回文子序列"><a href="#例题1：516-最长回文子序列" class="headerlink" title="例题1：516. 最长回文子序列"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210812151727243.png" alt="image-20210812151727243" style="zoom:80%;">

<p>典型的动态规划题，一般只要涉及到子序列最值，那么可以考虑动态规划来做题</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">我们可以定义dp[i][j]表示字符串s[i]到s[j]之间最长回文子序列
那么dp[i][j]就可以由之前的推导出来
if s[i] == s[j] =&gt; dp[i][j] = d[i+1][j-1] + 2
else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码如下：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0));
        for(int i = 0; i &lt; n; i++){
            dp[i][i] = 1;
        }
        for(int i = n - 2; i &gt;= 0; i--){
            //保证j要在i的后面，这样才有意义
            for(int j = i + 1; j &lt; n; j++){
                if(s[i] == s[j]){
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                }
                else{
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题2：629-K个逆序对数组"><a href="#例题2：629-K个逆序对数组" class="headerlink" title="例题2：629. K个逆序对数组"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/k-inverse-pairs-array/">629. K个逆序对数组</a></h4><img src="images/数据结构和算法/image-20211111131240134.png" alt="image-20211111131240134" style="zoom:80%;">

<p>这题一开始相的是全排列，但是复杂度太高，看了题解后发现动态规划也可以。</p>
<p><img src="images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211111132006522.png" alt="image-20211111132006522"></p>
<p><strong>代码如下：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int mod = 1e9 + 7;
class Solution {
public:
    int kInversePairs(int n, int k) {
        //dp[i][j]表示放了i个数字后逆序对为j的组合个数
        //dp[i][j] = dp[i][j - 1] - dp[i - 1][j - i] + dp[i - 1][j]
        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(1001, 0));
        for(int i = 1; i &lt;= n; i++) {
            dp[i][0] = 1;
            dp[i][1] = i - 1;
        }
        for(int i = 3; i &lt;= n; i++){
            for(int j = 2; j &lt;= k; j++){
                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
                if(j - i &gt;= 0) dp[i][j] -= dp[i - 1][j - i];
                if(dp[i][j] &gt;= mod) dp[i][j] -= mod;
                else if(dp[i][j] &lt; 0) dp[i][j] += mod;
            }
        }
        return dp[n][k];
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题3：375-猜数字大小-II"><a href="#例题3：375-猜数字大小-II" class="headerlink" title="例题3：375. 猜数字大小 II"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II</a></h4><img src="images/数据结构和算法/image-20211112125206027.png" alt="image-20211112125206027" style="zoom:80%;">

<p>这道题是一道典型的最大化最小值问题，其实周赛（266周赛.5920）中也做过这类型的题，不过那时候用的是二分查找，这里得用动态规划一个个遍历，二分查找每次只能遍历中点。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">/*
	我们可以定义dp[i][j]为分别以[i, j]作为正确数字所花费的最小金额
	因为我们得保证一定会赢，所以我们得考虑到最坏的情况，所以我们假设猜数字x
	如果对了，则加0
	否则，我们要花费 x 元，并且我们得选择花费区间更大的最为后续的猜测区间，这样能保证能糟糕的情况下获胜
	所以dp[i][j] = max(dp[i][x - 1], dp[x + 1][j]) + x
	同时题目要求最小金额，所以我们得取每个数字作为猜测的数字的花费最小的那种选择
*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int getMoneyAmount(int n) {
        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1));
        for(int i = n - 1; i &gt;= 1; i--){
            for(int j = i + 1; j &lt;= n; j++){
                int minCost = INT_MAX;
                for(int x = i; x &lt; j; x++){
                    int cost = max(dp[i][x - 1], dp[x + 1][j]) + x;
                    minCost = min(minCost, cost);
                }
                dp[i][j] = minCost;
            }
        }
        return dp[1][n];
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="例题1：5893-含特定字母的最小子序列"><a href="#例题1：5893-含特定字母的最小子序列" class="headerlink" title="例题1：5893. 含特定字母的最小子序列"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/">5893. 含特定字母的最小子序列</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211003142912371.png" alt="image-20211003142912371" style="zoom:80%;">

<p>很典型的一个贪心算法，我们可以先预处理一些数据，然后从第一个位置开始，从’a’开始试，满足条件的话就下一个位置，否则就试 ‘a’ + 1….一直试下去</p>
<p>那么预处理的数据要看满足的条件：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*
                   满足三个条件才可以继续下一个位置
                   	1.当前s中已使用的letter + 剩下的letter的数目 &gt;= repetition
                    2.已经构造的res中已使用的letter + 剩余的位置 &gt;= repetition
                    3.已经构造的res中剩余位置 &lt;= 字符串剩余的位置
*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还要注意一点，res = res + c 与 res += c的操作时间居然不一样</p>
<p>这是我看来string类型的 += 源码，它不需要重新赋值，而 = 是重新把 res 赋给res，所以以后写代码得注意了。不过还是有点不太确定，等我找到更正式的解答再补充上来。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">basic_string&amp; operator+=(_Elem _Ch)
		{	// append 1 * _Ch
		push_back(_Ch);
		return (*this);
		}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int MAXN = 5e4 + 50;
int nxt[MAXN][26];
int cnt[MAXN];
class Solution {
public:
    string smallestSubsequence(string s, int k, char letter, int repetition) {
        int n = s.length();  
        cnt[n + 1] = cnt[n] = 0; for (int i = 0; i &lt; 26; i++) nxt[n][i] = -1;
        for (int i = n - 1; i &gt;= 0; i--){
            cnt[i] = cnt[i + 1];
            if (s[i] == letter) cnt[i] += 1;
            for (int j = 0; j &lt; 26; j++) nxt[i][j] = nxt[i + 1][j];
            nxt[i][s[i] - 'a'] = i;
        }
        //进行贪心的查找，我们对于每个位置从'a'开始试，如果满足条件则加入，进入下一个位置，否则换'a' + 1..

        string ans = "";
        //p表示当前位置，cur表示res当前包含了多少个letter
        int cur = 0, p = 0;
        for (int i = 0; i &lt; k; i++){
            for (char c = 'a'; c &lt;= 'z'; c++){
                //如果根本没有这个字符，那么就换下一个
                int pos = nxt[p][c - 'a']; if (pos == -1) continue;
                /*
                    满足三个条件才可以继续下一个位置
                    1.当前s中已使用的letter + 剩下的letter的数目 &gt;= repetition
                    2.已经构造的res中已使用的letter + 剩余的位置 &gt;= repetition
                    3.已经构造的res中剩余位置 &lt;= 字符串剩余的位置
                */
                if (cur + cnt[pos] &gt;= repetition 
                    &amp;&amp; cur + (letter == c? 1:0) + k - 1 - i &gt;= repetition
                    &amp;&amp; k - 1 - i &lt;= n - pos - 1){
                    ans += c;
                    cur += (c == letter ? 1:0);
                    p = pos + 1;
                    break;
                }else continue;
            }
        }
        
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题2：5878-重复-K-次的最长子序列"><a href="#例题2：5878-重复-K-次的最长子序列" class="headerlink" title="例题2：5878. 重复 K 次的最长子序列"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-subsequence-repeated-k-times/">5878. 重复 K 次的最长子序列</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210919132415118.png" alt="image-20210919132415118" style="zoom:80%;">

<p>对于这道题我一开始是真的没思路，比赛打完了看了坑神的视频才明白，原来暴力就行，tql</p>
<p>其实这题还是有提示的，2 &lt;= n &lt; k * 8，所以这个重复k次的子序列的长度不会超过8，即长度为1~7</p>
<p>所以我们可以遍历长度为1~7的所有情况，把长度为len的所有子序列都遍历一遍，每个遍历26次，每次对应一个字母，当然从大大小，因为长度相同时要返回字典序最大的那个子序列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//其实这里我还不知道可以这么搞，学到了
vector&lt;string&gt; savAns[8];
class Solution {
public:
    //检验这个子序列s0是否在s中重复了k次
    bool check(const string&amp; s,const string&amp; s0, int k){
        int n = s.size();
        int m = s0.size();
        int j = 0, target = m * k;
        for(int i = 0; i &lt; n &amp;&amp; j &lt; target; i++){
            if(s[i] == s0[j % m]) j++;
        }
        return j == target;
    }
    string longestSubsequenceRepeatedK(string s, int k) {
        for(int i = 0; i &lt; 8; i++) savAns[i].clear();
        savAns[0].push_back("");
        //注意到 2 &lt;= n &lt; k * 8，说明重复k次子序列的长度不会超过7（1~7）
        //所有我们可以从长度为1的子序列开始遍历
        for(int len = 1; len &lt;= 7; len++){
            //因为相同长度的字符串还要按照字典序大的返回，所有我们遍历时就按照字典序大的情况遍历
            for(string&amp; cur : savAns[len - 1]){
                //把26个字母都加到cur子序列上试一试，看看满不满足出现k次的要求
                for(char c = 'z'; c &gt;= 'a'; c--){
                    string nxt = cur + c;
                    if(check(s, nxt, k)){
                        savAns[len].push_back(nxt);
                    }
                }
            }
        }
        //最后我们在从最长的子序列中找出字典序最大的那个
        for(int i = 7; i &gt;= 1; i--){
            if(savAns[i].size() &gt; 0) return savAns[i][0];
        }
        return "";
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="例题1：82-删除排序链表中的重复元素-II"><a href="#例题1：82-删除排序链表中的重复元素-II" class="headerlink" title="例题1：82. 删除排序链表中的重复元素 II"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210804161608455.png" alt="image-20210804161608455" style="zoom:80%;">

<p>方法一：采用哈希表把数字出现的次数记录下来，然后只把出现次数为1的元素添加到新的链表后面</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head || !head-&gt;next){
            return head;
        }
        unordered_map&lt;int,int&gt; fre;
        ListNode* cur = head;
        while(cur){
            fre[cur-&gt;val]++;
            cur = cur-&gt;next;
        }
        cur = head;
        ListNode* node = new ListNode(-1);
        ListNode* res = node;
        while(cur){
            if(fre[cur-&gt;val] == 1){
                node-&gt;next = new ListNode(cur-&gt;val);
                node = node-&gt;next;
            }
            cur = cur-&gt;next;
        }
        return res-&gt;next;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>方法二：采用一次遍历的方法，我们先创造一个哑点，哑点的next指向head节点，然后如果next和next-&gt;next相同，则记录这个数字为x，然后把next等于x的删除就行。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head) return head;
        ListNode* dummy = new ListNode(0, head);
        ListNode* cur = dummy;
        while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next){
            if(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val){
                int x = cur-&gt;next-&gt;val; 
                while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == x){
                    cur-&gt;next = cur-&gt;next-&gt;next;
                }
            }
            else{
                cur = cur-&gt;next;
            }
        }
        return dummy-&gt;next;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>做动态规划的题首先需要明白有哪几个步骤要考虑：</p>
<ol>
<li>dp数组的含义，这是首先要弄清楚的，我觉得可以先举例子看一看</li>
<li>状态转移方程，这个是比较难的部分了，同样举列子，然后根据dp数组含义来进行思考</li>
<li>初始化</li>
<li>遍历的方向</li>
<li>当结果不对时，可以打印dp数组来观察是哪里出现了问题</li>
</ol>
<h3 id="例题1：576-出界的路径数"><a href="#例题1：576-出界的路径数" class="headerlink" title="例题1：576. 出界的路径数"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/out-of-boundary-paths/">576. 出界的路径数</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210815220502758.png" alt="image-20210815220502758" style="zoom:80%;">

<p>这题我本来是用bfs做的，但是超时了，我稍微剪枝了一下但还是不行，我先把代码贴在这，以后更懂了再看能不能优化。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.push({startRow, startColumn});
        int cnt = 0;
        for(int k = 0; k &lt; maxMove; k++){
            int sz = q.size();
            int move = maxMove - k;
            for(int i = 0; i &lt; sz; i++){
                pair&lt;int, int&gt; cur = q.front();
                q.pop();
                int x = cur.first;
                int y = cur.second;
                if(x &gt; move &amp;&amp; m - x &gt; move &amp;&amp; y &gt; move &amp;&amp; n - y &gt; move) continue;
                for(int j = -1; j &lt; 2; j += 2){
                    //上下节点
                    if(x + j &gt;=0 &amp;&amp; x + j &lt; m){
                        q.push({x + j, y});
                    }
                    else{
                        cnt++;
                    }
                    //左右节点
                    if(y + j &gt;= 0 &amp;&amp; y + j &lt; n){
                        q.push({x, y + j});
                    }
                    else{
                        cnt++;
                    }
                }
            }
        }
        return cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>动态规划思路：我们先观察状态，发现每个点有移动步数和到达该点的路径数量两个状态，所有我们可以设计一个三维数组记录第 k 步走到点(x, y)的路径数量。然后既可以遍历四周的点，如果下一步可以走出边界，那么cnt就加上这点的路径数量。如果不行，那么下一步的给点都加上该点的路径数量。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(maxMove + 1, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, 0)));
        vector&lt;vector&lt;int&gt;&gt; direction = {{-1, 0},{1, 0},{0, -1},{0, 1}};
        //base case
        dp[0][startRow][startColumn] = 1;
        int cnt = 0;
        int mod = 1e9+7;
        for(int k = 0; k &lt; maxMove; k++){
            for(int i = 0; i &lt; m; i++){
                for(int j = 0; j &lt; n; j++){
                    //走了k步后到达(i, j)点的路径个数
                    int count = dp[k][i][j];
                    if(count &gt; 0){
                        //遍历四个方向
                        for(auto&amp; dir : direction){
                            int x = i + dir[0], y = j + dir[1];
                            if(x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n){
                                dp[k + 1][x][y] = (dp[k + 1][x][y] + count) % mod;
                            }
                            else{
                                cnt = (cnt + count) % mod;
                            }
                        }
                    }
                    
                }
            }
        }
        return cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题2：526-优美的排列"><a href="#例题2：526-优美的排列" class="headerlink" title="例题2：526. 优美的排列"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/beautiful-arrangement/">526. 优美的排列</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210816133744115.png" alt="image-20210816133744115" style="zoom:80%;">

<p>这题我自己想的是回溯方法来做的，不过时间复杂度有点高</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int cnt = 0;
    int countArrangement(int n) {
        vector&lt;int&gt; res;
        backtrack(res, n);
        return cnt;
    }
    void backtrack(vector&lt;int&gt;&amp; res, int n){
        if(res.size() == n){
            cnt++;
            return;
        }
        //从选择列表中选择
        for(int i = 1; i &lt;= n; i++){
            //排除已经选择了的数
            if(count(res.begin(), res.end(), i)){
                continue;
            }
            int m = res.size();
            if(i % (m + 1) == 0 || (m + 1) % i == 0){
                res.push_back(i);
                backtrack(res, n);
                res.pop_back();
            }                          
        }
    } 
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>官方解答是用的动态规划，思路不错，利用了位运算来解决该题，感觉和子集这个题差不多的思路</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int countArrangement(int n) {
        //利用位运算计算一种状态
        vector&lt;int&gt; dp(1 &lt;&lt; n, 0);
        dp[0] = 1;
        for(int mask = 1; mask &lt; (1 &lt;&lt; n); mask++){
            //计算二进制数mask中有多少个1
            int num = __builtin_popcount(mask);
            //遍历mask的每一位
            for(int i = 0; i &lt; n; i++){
                if(mask &amp; (1 &lt;&lt; i) &amp;&amp; (num % (i + 1) == 0 || (i + 1) % num == 0)){
                    dp[mask] += dp[mask ^ (1 &lt;&lt; i)];
                }
            }
        }
        return dp[(1 &lt;&lt; n) - 1];
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>这里还有一个解答非常好</strong></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// 用 mask 的二进制表示选取状态，n 个数字用 n 位表示，第 i 位为 1 代表数字 i+1 已被选取（i从0开始），n 中 1 的个数 m 代表前 m 位已放置
// 例如：二进制 100110 共三个1，代表排列的前三位已放置数字，三个1分别在二进制第 1、2、5位置上(从右侧开始，从0开始计数）, 所以 2、3、6三个数字被选取，综合起来就是表示：2 3 6 这三个数字被放到了排列的前三位，三个数字完美排列方式未知，通过枚举 mask 进行计算

  class Solution {
      public int countArrangement(int n) {
          // 用来存储中间结果，f[6] = f[000110] = 数字2、3在前两位时的完美排列数量
          int[] f = new int[1 &lt;&lt; n];
          f[0] = 1;
          // 通过 mask 进行枚举，最终目的是为了得到二进制 mask = (11..11)n 时，总的完美排列数 
          for (int mask = 1; mask &lt; (1 &lt;&lt; n); mask++) {
              int num = Integer.bitCount(mask);
              // 遍历 mask 的每一位，仍以 mask = 100110 为例，此 mask 代表 2 3 6三个数字在排列的前三位
              // 求三个数字 2 3 6 的完美排列方式，则先确定2 3 6哪些数字能放到第三位，然后累加另外两个数字的完美排列数量来获得
              // 2 3 6，第三位可以为 6，则 f[100110] += f[000110] (2、3在前两位时的完美排列数量)
              // 2 3 6，第三位可以为 3，则 f[100110] += f[100010] (2、6在前两位时的完美排列数量)
              for (int i = 0; i &lt; n; i++) {
                  // mask &amp; (1&lt;&lt;i) 用来判断 mask 第 i 位是否为 1，如果为 1，说明第 i+1 个数字被选取
                  // ((num % (i + 1)) == 0 || (i + 1) % num == 0) 判断被选取的数字 i+1 能否放到位置 num 上，
                  // 即：先从被选取的数字中找到能放到最高位 num 的数字，然后将剩余 num-1 个数字的完美排列方式累加到f[mask]中
                  if ((mask &amp; (1 &lt;&lt; i)) != 0 &amp;&amp; ((num % (i + 1)) == 0 || (i + 1) % num == 0)) {
                      // mask ^ (1 &lt;&lt; i) 将 mask 第 i 位设置为 0
                      f[mask] += f[mask ^ (1 &lt;&lt; i)];
                  }
              }
          }
          return f[(1 &lt;&lt; n) - 1];
      }
  }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题3：552-学生出勤记录-II"><a href="#例题3：552-学生出勤记录-II" class="headerlink" title="例题3：552. 学生出勤记录 II"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/student-attendance-record-ii/">552. 学生出勤记录 II</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210818144012011.png" alt="image-20210818144012011" style="zoom:80%;">

<p>这一题我看到了一个题解，让我知道了动态规划的精髓，动态规划在于推到，我们如何根据前面的几种状态推导出相同条件的下一状态。</p>
<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210818144215298.png" alt="image-20210818144215298" style="zoom:80%;">

<p>所以我们根据这些推到公式很容易就写出来状态方程</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int checkRecord(int n) {
        vector&lt;int&gt; dp(6, 0);
        vector&lt;int&gt; res(6, 0);
        dp[0] = 1;
        int mod = 1e9+7;
        for(int i = 0; i &lt; n; i++){
            //这里相加会越界，所以我们先把它转化成longlong类型，然后取余就可以了
            //下面就是上述方程的代码形式，所以dp问题我们只需找到状态的推到就行了
            res[0] = ((long long)dp[0] + dp[2] + dp[4]) % mod;
            res[1] = ((long long)dp[0] + dp[1] + dp[2]+ dp[3]+ dp[4]+ dp[5]) % mod;
            res[2] = dp[0] % mod;
            res[3] = dp[1] % mod;
            res[4] = dp[2] % mod;
            res[5] = dp[3] % mod;
            dp = res;
        }
        int cnt = 0;
        for(int num : dp){
            cnt = (cnt + num) % mod;
        }
        return cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当然官方的题解也写得不错，我感觉官方的容易想一点，不过还是那个推导的思想</p>
<p>链接在这：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/student-attendance-record-ii/solution/xue-sheng-chu-qin-ji-lu-ii-by-leetcode-s-kdlm/">学生出勤记录 II - 学生出勤记录 II - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int checkRecord(int n) {
        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n + 1, vector&lt;vector&lt;int&gt;&gt;(2, vector&lt;int&gt;(3, 0)));
        dp[0][0][0] = 1;
        int mod = 1e9+7;
        for(int i = 1; i &lt;= n; i++){
            //P结尾
            for(int j = 0; j &lt;= 1; j++){
                for(int k = 0; k &lt;= 2; k++){
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % mod;
                }
            }
            //A结尾
            for(int k = 0;k &lt;= 2; k++){
                dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % mod;
            }
            //L结尾
            for(int j = 0; j &lt;= 1; j++){
                for(int k = 1; k &lt;= 2; k++){
                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % mod;
                }
            }
        }
        int cnt = 0;
        for(int j = 0; j &lt;= 1; j++){
            for(int k = 0; k &lt;= 2; k++){
                cnt = (cnt + dp[n][j][k]) % mod;
            }
        }
        return cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们还可以把上述的动态规划压缩，使用快速幂矩阵算法把时间复杂度降到logN</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    static constexpr int mod = 1e9+7;
    //矩阵快速幂
    vector&lt;vector&lt;long&gt;&gt; pow(vector&lt;vector&lt;long&gt;&gt; mat, int n){
        //这里ret表示的是dp[n]的情况dp[n]=[dp[n][0],dp[n][1],dp[n][2],dp[n][3]​,dp[n][4],dp[n][5]]
        //只有dp[n][0] = 1的，其它都为0
        //即ret是表示的初始值
        vector&lt;vector&lt;long&gt;&gt; ret = {{1, 0, 0, 0, 0, 0}};
        while(n &gt; 0){
            if(n &amp; 1){
                ret = mupltiply(ret, mat);
            }
            n &gt;&gt;= 1;
            mat = mupltiply(mat, mat);
        }
        return ret;
    }
    vector&lt;vector&lt;long&gt;&gt; mupltiply(vector&lt;vector&lt;long&gt;&gt; a, vector&lt;vector&lt;long&gt;&gt; b){
        int rows = a.size(), columns = b[0].size(), temp = b.size();
        vector&lt;vector&lt;long&gt;&gt; c(rows, vector&lt;long&gt;(columns));
        for(int i = 0; i &lt; rows; i++){
            for(int j = 0; j &lt; columns; j++){
                for(int k = 0; k &lt; temp; k++){
                    c[i][j] += a[i][k] * b[k][j];
                    c[i][j] %= mod;
                }
            }
        }
        return c;
    }
    int checkRecord(int n) {
        vector&lt;vector&lt;long&gt;&gt; mat = {{1,1,0,1,0,0},{1,0,1,1,0,0},{1,0,0,1,0,0},{0,0,0,1,1,0},{0,0,0,1,0,1},{0,0,0,1,0,0}};
        vector&lt;vector&lt;long&gt;&gt; res = pow(mat, n);
        long sum = accumulate(res[0].begin(), res[0].end(), 0ll);
        return (int)(sum % mod);
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题4：5852-最小化目标值与所选元素的差"><a href="#例题4：5852-最小化目标值与所选元素的差" class="headerlink" title="例题4：5852. 最小化目标值与所选元素的差"></a>例题4：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimize-the-difference-between-target-and-chosen-elements/">5852. 最小化目标值与所选元素的差</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210822125041909.png" alt="image-20210822125041909" style="zoom:80%;">

<p>这题暴力枚举是可能不行的，而且求最优的情况，所以我们可以使用动态规划来解决此。</p>
<p>这是当时周赛的题目，比赛时我没做出来，主要没想到该用什么来表示状态。</p>
<p>看了个up主的思路很不错，我们可以取每个数字是否可能被取到这个作为dp的状态</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int MAXN = 70;
const int MAXV = MAXN * MAXN;
bool dp[MAXN][MAXV];//dp[i][j]表示取了前i层每一个数字后，和为j的可能性

class Solution {
public:
    int minimizeTheDifference(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int target) {
        memset(dp, false, sizeof(dp));
        int n = mat.size();
        int m = mat[0].size();
        //base case
        for(int i = 0; i &lt; m; i++) dp[0][mat[0][i]] = true;
        
        for(int i = 1; i &lt; n; i++){
            //把每一个i对应的数字的可能性记录下来
            for(int j = 0; j &lt; MAXV; j++){
                if(dp[i - 1][j] == false) continue;
                //把相加的情况记录下来
                for(int k = 0; k &lt; m; k++){
                    if(j + mat[i][k] &gt;= MAXV) continue;
                    dp[i][j + mat[i][k]] = true;
                }
            }
        }
        //最后把n - 1对应的可能出现的数字比较一下
        int ans = MAXV + 1;
        for(int i = 0; i &lt; MAXV; i++){
            if(dp[n - 1][i]) ans = min(ans, abs(i - target));
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题5：600-不含连续1的非负整数"><a href="#例题5：600-不含连续1的非负整数" class="headerlink" title="例题5：600. 不含连续1的非负整数"></a>例题5：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210911151421618.png" alt="image-20210911151421618" style="zoom:80%;">

<p>经典数位dp了，一般是从高位往低位扫描，这里我们dp[i]表长度位i的二进制数满足条件的个数。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/solution/leetcode-ac-dong-tai-gui-hua-jie-fa-han-eqceq/">动态规划解法(类似于斐波那契数列)，含详细注释，十分容易理解【大白技术控】 - 不含连续1的非负整数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>这个题解写的很不错，我们通过模拟发现一个规律，dp[i] = dp[i - 1] + dp[i - 2]</p>
<p>然后举个例子把，一个数二进制位10010110，我们要找小于该数并且满足没有连续1的条件的个数</p>
<pre class="line-numbers language-none"><code class="language-none">对于10010110，我们从高位开始，高位为1，那么我们就要满足其中的一个条件，那么可能满足没有连续1的数的这一位都为0，
1 0010110
0 0000000
0 1111111
我们只能在这个区间内找，也就是长度为7的二进制数的满足个数，即dp[7]
同理，接下来是第二个1（为什么不着0呢，因为无论后面为1还是0，都不会比该数小）
1001 0110
1000 0000
1000 1111
即dp[4]
100101 10
100101 00
dp[2]
1001011 0
1001010 0
1001010 1
dp[1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int findIntegers(int n) {
        vector&lt;int&gt; dp(32);
        dp[0] = 1;
        dp[1] = 2;
        for(int i = 2; i &lt; 32; i++) dp[i] = dp[i - 1] + dp[i - 2];
        int res = 0; //记录合法的个数
        int pre = 0;//记录前一位是否为1
        int k = 30; //因为n &lt;= 10^9也就是2^30
        while(k &gt;= 0){
            //从高位向低位扫描,如果高位是1的话，就把高位下面几位的合法个数加入进来
            if(n &amp; (1 &lt;&lt; k)){
                //这里先加是因为我们把当前为1的数字看为0，这位数字后面的位才不需要考虑
                res += dp[k];
                if(pre) return res;
                pre = 1;
            }
            else{
                pre = 0;
            }
            k--;
        }
        //最后加上该数本身(因为能在这里返回说明n的二进制中没有连续1，所以可以加上这个数)
        return res + 1;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这题难度还是有点的大呀。</p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="例题1：46-全排列"><a href="#例题1：46-全排列" class="headerlink" title="例题1：46. 全排列"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210812210827518.png" alt="image-20210812210827518" style="zoom:80%;">

<p>经典回溯算法题，可以把它看成决策树的过程，每次都是从选择列表中做出选择加入到路径中，最后撤销选择</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; ans;
        backtrack(nums, ans);
        return res;
    }
    void backtrack(vector&lt;int&gt; nums, vector&lt;int&gt; ans){
        //触发结束条件
        if(ans.size() == nums.size()){
            res.push_back(ans);
            return;
        }
        //开始从选择列表中把选择加入到路径
        for(int i = 0; i &lt; nums.size(); i++){
            //排除不合法的选择
            if(count(ans.begin(), ans.end(), nums[i]))
                continue;
            //做出选择
            ans.push_back(nums[i]);
            //进入下一决策树
            backtrack(nums, ans);
            //撤销选择
            ans.pop_back();
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>官方给了给回溯的思路很不错，left表示从左到右填第几个位置，nums数组中[0, left - 1]都是已经用过的数字，那么我们就要把剩余的[left, nums.size() - 1]数填入到排列中</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
        backtrack(nums, 0, nums.size());
        return res;
    }
    void backtrack(vector&lt;int&gt;&amp; output, int left, int n){
        //如果所有数都填完了
        if(left == n){
            res.emplace_back(output);
            return;
        }
        //填入剩余nums[left, n - 1]数字
        for(int i = left; i &lt; n; i++){
            //动态维护数组
            swap(output[i], output[left]);
            //继续递归填入下一个数
            backtrack(output, left + 1, n);
            //撤销操作
            swap(output[i], output[left]);
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="例题2：47-全排列-II"><a href="#例题2：47-全排列-II" class="headerlink" title="例题2：47. 全排列 II"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210812212320908.png" alt="image-20210812212320908" style="zoom:80%;">

<p>这题与上题全排列差不多，就是多个重复的约束条件，判断一下重复就行了</p>
<p>利用数组来记录nums[i]是否被访问</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        vector&lt;int&gt; ans;
        vector&lt;bool&gt; used(nums.size(), false);
        backtrack(nums, ans, used);
        return res;
    }
    void backtrack(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; ans, vector&lt;bool&gt;&amp; used){
        //触发结束条件
        if(ans.size() == nums.size()){
            res.push_back(ans);
            return;
        }
        //开始从选择列表中把选择加入到路径
        for(int i = 0; i &lt; nums.size(); i++){
            //排除不合法的选择(如果有重复nums中有数字的话，就要在这里进行改变)
            if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])
                continue;
            //做出选择
            ans.push_back(nums[i]);
            used[i] = true;
            //进入下一决策树
            backtrack(nums, ans, used);
            //撤销选择
            ans.pop_back();
            used[i] = false;
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题3：39-组合总和"><a href="#例题3：39-组合总和" class="headerlink" title="例题3：39. 组合总和"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210816195325203.png" alt="image-20210816195325203" style="zoom:80%;">

<p>这道题我们可以就是标准的回溯算法模板，不过我们在选择列表中要使用startIndex，当我们对需要组合的顺序没有要求时，就要使用startIndex了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; ans;
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {
        res.clear();
        ans.clear();
        sort(candidates.begin(), candidates.end());
        backtrack(candidates, target, 0, 0);
        return res;
    }
    void backtrack(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex){
        if(sum &gt; target)
            return;
        if(sum == target){
            res.push_back(ans);
            return;
        }
        //对组合的顺序没有要求的话，就要i = startIndex。否则直接i = 0
        for(int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++){
            sum += candidates[i];
            ans.push_back(candidates[i]);
            backtrack(candidates, target, sum, i);
            sum -= candidates[i];
            ans.pop_back();
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题4：40-组合总和-II"><a href="#例题4：40-组合总和-II" class="headerlink" title="例题4：40. 组合总和 II"></a>例题4：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210816195652204.png" alt="image-20210816195652204" style="zoom:80%;">

<p>这题就比上一题多了candidates中有重复元素，并且每个下标的元素在每个组合中只能使用一次这个条件，所以我们要在上一题的基础上再加上每个数字使用一次的限制，我们可以使用一个bool向量来记录每个下标元素的使用情况。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; ans;
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtrack(candidates, target, 0, 0);
        return res;
    }
    void backtrack(vector&lt;int&gt;&amp; candidates, int target, int sum, int index, vector&lt;bool&gt;&amp; used){
        if(sum &gt; target)
            return;
        if(sum == target){
            res.push_back(ans);
            return;
        }
        for(int i = index; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++){
            //这里多了个判断是否已经用过的语句，其余都差不多
            if(used[i] || (i != 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !used[i - 1]))
                continue;
            sum += candidates[i];
            ans.push_back(candidates[i]);
            used[i] = true;
            backtrack(candidates, target, sum, i + 1,used);
            sum -= candidates[i];
            ans.pop_back();
            used[i] = false;
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>也可以使用index进行去重，因为其本质就是不重复使用同一层已经使用过的元素</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; ans;
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtrack(candidates, target, 0, 0);
        return res;
    }
    void backtrack(vector&lt;int&gt;&amp; candidates, int target, int sum, int index){
        if(sum &gt; target)
            return;
        if(sum == target){
            res.push_back(ans);
            return;
        }
        for(int i = index; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++){
            //对同一层使用过的元素进行跳过
            if(i &gt; index &amp;&amp; candidates[i] == candidates[i - 1])
                continue;
            sum += candidates[i];
            ans.push_back(candidates[i]);
            backtrack(candidates, target, sum, i + 1);
            sum -= candidates[i];
            ans.pop_back();
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题5：17-电话号码的字母组合"><a href="#例题5：17-电话号码的字母组合" class="headerlink" title="例题5：17. 电话号码的字母组合"></a>例题5：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210819161355241.png" alt="image-20210819161355241" style="zoom:80%;">

<p>这题倒是和上面的组合题很类似，都是可以用很多循环来暴力出来，但是循环不确定，所以就要用回溯来解决。</p>
<p>我们发现回溯树的层数和digits的长度相同，所以每次回溯都是深度加一</p>
<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210819161650447.png" alt="image-20210819161650447" style="zoom:80%;">

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    const string nums[10] = {
        "", //0
        "", //1
        "abc", //2
        "def", //3
        "ghi", //4
        "jkl", //5
        "mno", //6
        "pqrs",//7
        "tuv",//8
        "wxyz"//9
    };
    vector&lt;string&gt; res;
    string s;
    vector&lt;string&gt; letterCombinations(string digits) {
        s.clear();
        res.clear();
        if(digits.size() == 0)
            return res;
        backtrack(digits, 0);
        return res;
    }
    void backtrack(const string&amp; digits, int index){
        if(index == digits.size()){
            res.push_back(s);
            return;
        }
        int digit = digits[index] - '0';
        string letters = nums[digit];
        for(int i = 0; i &lt; letters.size(); i++){
            s.push_back(letters[i]);
            backtrack(digits, index + 1);
            s.pop_back();
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题6：22-括号生成"><a href="#例题6：22-括号生成" class="headerlink" title="例题6：22. 括号生成"></a>例题6：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210819171945650.png" alt="image-20210819171945650" style="zoom:80%;">

<p>这题还是比较新颖的，但是还是画决策树就行了，我们发现右括号生成时，左括号的剩余数量一定得小于右括号的剩余数量，否则无法匹配，而左括号生成时，剩余数量一定得大于0</p>
<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210819172034376.png" alt="image-20210819172034376" style="zoom:60%;">

<p><strong>代码如下：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; res;
    string s;
    vector&lt;string&gt; generateParenthesis(int n) {
        res.clear();
        s.clear();
        if(n == 0) return res;
        backtrack(n, n);
        return res;
    }
    void backtrack(int left, int right){
        if(left == 0 &amp;&amp; right == 0){
            res.push_back(s);
            return;
        }
        if(left &gt; right) return;
        //产生左分支，即'('
        if(left &gt; 0){
            s.push_back('(');
            backtrack(left - 1, right);
            s.pop_back();
        }
        //产生右分支，即')'
        if(right &gt; 0){
            s.push_back(')');
            backtrack(left, right - 1);
            s.pop_back();
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面我们使用的是减法来进行回溯的，我们还可以使用加法进行回溯，就是思路反过来，左括号生成时，已生成的数量严格小于n；右括号生成时，左括号的数量严格大于右括号</p>
<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210819172417158.png" alt="image-20210819172417158" style="zoom:60%;">

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; res;
    string s;
    vector&lt;string&gt; generateParenthesis(int n) {
        res.clear();
        s.clear();
        if(n == 0) return res;
        backtrack(0, 0, n);
        return res;
    }
    void backtrack(int left, int right, int n){
        if(left == n &amp;&amp; right == n){
            res.push_back(s);
            return;
        }
        //当左括号数量小于右括号时，剪枝
        if(left &lt; right) return;
        //生成左括号
        if(left &lt; n){
            s.push_back('(');
            backtrack(left + 1, right, n);
            s.pop_back();
        }
        //生成右括号
        if(right &lt; n){
            s.push_back(')');
            backtrack(left, right + 1, n);
            s.pop_back();
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后看到了一位大佬写的题解，BFS做得，属实惊艳到了我，感觉只要是DFS能做的，BFS都能做，只不过使用队列来显式的显示状态比较麻烦</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    struct Node{
        string s;
        int left;
        int right;
    };
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;string&gt; res;
        queue&lt;Node&gt; q;
        Node p = {"", 0, 0};
        q.push(p);
        while(!q.empty()){
            Node cur = q.front();
            q.pop();
            //将周围节点加入进来
            if(cur.left &lt; cur.right) continue;
            //如果满足条件，加入到数组中
            if(cur.left == n &amp;&amp; cur.right == n){
                res.push_back(cur.s);
                continue;
            }
            //加入左节点，即左括号
            if(cur.left &lt; n){
                Node point = {cur.s + '(', cur.left + 1, cur.right};
                q.push(point);
            }
            //加入右节点，即右括号
            if(cur.right &lt; n){
                Node point = {cur.s + ')', cur.left, cur.right + 1};
                q.push(point);
            }
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题6：79-单词搜索"><a href="#例题6：79-单词搜索" class="headerlink" title="例题6：79. 单词搜索"></a>例题6：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210819205442980.png" alt="image-20210819205442980" style="zoom:80%;">



<p>这题我一开始用的是BFS做的，但是没做出来，很麻烦，所以还是换成了回溯算法。</p>
<p>说一下思路吧，我们把每个点作为起点进行回溯，多开一个二维数组来记录是否访问过。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        int n = board.size();
        int m = board[0].size();
        vector&lt;vector&lt;bool&gt;&gt; used(n, vector&lt;bool&gt;(m, false));
        for(int i = 0; i &lt; n; i++){
            for(int j = 0; j &lt; m; j++){
                if(backtrack(board, word, i, j, 0, used)){
                    return true;
                }
            }
        }
        return false;
    }
    bool backtrack(vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word, int x, int y, int index, vector&lt;vector&lt;bool&gt;&gt;&amp; used){
        if(index == word.size()){
            return true;
        }
        if(x &lt; 0 || x&gt;=board.size() || y&lt;0 || y&gt;=board[0].size() || board[x][y] != word[index])   
            return false;
        if(!used[x][y]){
            used[x][y] = true;
            if(backtrack(board, word, x - 1, y, index + 1, used)
               || backtrack(board, word, x + 1, y, index + 1, used)
               || backtrack(board, word, x, y - 1, index + 1, used)
               || backtrack(board, word, x, y + 1, index + 1, used)){
                return true;
            }
            used[x][y] = false;
        }
        return false;
    }   
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题7：698-划分为k个相等的子集"><a href="#例题7：698-划分为k个相等的子集" class="headerlink" title="例题7：698. 划分为k个相等的子集"></a>例题7：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210907123441739.png" alt="image-20210907123441739" style="zoom:80%;">

<p>这题我们可以想化成k个分支，每个分支上元素的和相同。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) {
        //回溯法，k个分支
        int sum = 0;
        /*
            为什么要排序呢，其实不排序这道题也能做对，但是由于时间的关系就t了。
            排序就是为了优化时间，怎么优化呢？
            我们从nums中最大的数开始找，如果最大的数比子集和都要大，或者装下它后没到子集和的大小但是装不下nums中最小的值了，
            那么这个nums绝对是false，因为有一个这么大的数在nums里，你把它放在哪个子集里都不合适。
        */
        sort(nums.begin(), nums.end());
        for(int num : nums) sum += num;
        if(sum == 0 || sum % k != 0) return false;
        vector&lt;int&gt; size(k, 0);
        return backtrack(nums, nums.size() - 1, size, sum / k);
    }
    bool backtrack(vector&lt;int&gt;&amp; nums, int index, vector&lt;int&gt;&amp; size, int target){
        if(index == -1){
            for(int i = 1; i &lt; size.size(); i++){
                if(size[i] != size[i - 1]) return false;
            }
            return true;
        }
        //如果没有返回，说明还有元素没有访问到
        //剪枝一下，如果超过了target则返回
        for(int i = 0; i &lt; size.size(); i++){
            if(size[i] + nums[index] &gt; target || (i &gt; 0 &amp;&amp; size[i] == size[i - 1])) continue;
            size[i] += nums[index];
            if(backtrack(nums, index - 1, size, target)) return true;
            size[i] -= nums[index];
        }
        return false;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题8：301-删除无效的括号"><a href="#例题8：301-删除无效的括号" class="headerlink" title="例题8：301. 删除无效的括号"></a>例题8：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></h3><img src="images/数据结构和算法/image-20211027130149766.png" alt="image-20211027130149766" style="zoom:80%;">

<p>这题其实用回溯感觉不是很难理解，不过就是自己想不到啊/(ㄒoㄒ)/~~</p>
<p><strong>回溯：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    //这题没我想的那么复杂啊，直接dfs回溯就行了。
    //利用set进行去重
    set&lt;string&gt; res;
    vector&lt;string&gt; removeInvalidParentheses(string s) {
        res.clear();
        vector&lt;string&gt; ans;
        backtrack(s, 0, 0, 0, "");
        int maxSize = 0;
        for(string str : res){
            maxSize = maxSize &gt; str.size() ? maxSize : str.size();
        }
        for(string str : res){
            if(str.size() == maxSize) ans.push_back(str);
        }
        return ans;
    }
    void backtrack(string&amp; s, int index, int left, int right, string path){
        //如果目前右括号数量大于左括号的数量，那么不符合要求
        if(left &lt; right) return;

        if(index == s.size()){
            if(left == right){
                res.insert(path);
            }
            return;
        }

        if(s[index] == '('){
            //两个选择，加入或不加入
            backtrack(s, index + 1, left + 1, right, path + '(');
            backtrack(s, index + 1, left, right, path);
        }
        else if(s[index] == ')'){
            //其实这里就已经是回溯了
            backtrack(s, index + 1, left, right + 1, path + ')');
            backtrack(s, index + 1, left, right, path);
        }
        else{
            //字母必须加入
            backtrack(s, index + 1, left, right, path + s[index]);
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>BFS版感觉就需要点想法了，我们可以从长度大小遍历，如果一开始就是个合法的字符串，那么直接返回。否则，减去一个 ‘(‘  或  ‘)’ ，然后加入set中就行了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; removeInvalidParentheses(string s) {
        set&lt;string&gt; res;
        vector&lt;string&gt; ans;
        queue&lt;string&gt; q;
        q.push(s);
        while(!q.empty()){
            //当前层的数量
            int sz = q.size();
            set&lt;string&gt; st;  //利用set进行过滤下一层的字符串，因为减去一个字符可能会重复
            for(int i = 0; i &lt; sz; i++){
                string cur = q.front(); q.pop();
                //如果当前层有效，就不需要找下一层了，因为下一层会减去一个字符，所以长度肯定比这一次小
                if(isValid(cur)){
                    res.insert(cur);
                }
                //如果当前层还是空的就进入下一层
                if(res.empty()){
                    for(int j = 0; j &lt; cur.size(); j++){
                        if(cur[j] == '(' || cur[j] == ')'){
                            st.insert(cur.substr(0, j) + cur.substr(j + 1));
                        }
                    }
                }
            }
            if(!res.empty()){
                break;
            }
            for(string str : st) q.push(str);
        }
        for(string str: res) ans.push_back(str);
        return ans;
    }
    bool isValid(string s){
        int count = 0;
        for(char c : s){
            if(count &lt; 0) return false;
            if(c == '(') count++;
            else if(c == ')') count--; 
        }
        return count == 0;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="DFS（深度优先搜索）"><a href="#DFS（深度优先搜索）" class="headerlink" title="DFS（深度优先搜索）"></a>DFS（深度优先搜索）</h2><h3 id="例题1：212-单词搜索-II（字典树）"><a href="#例题1：212-单词搜索-II（字典树）" class="headerlink" title="例题1：212. 单词搜索 II（字典树）"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a>（字典树）</h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210916132627367.png" alt="image-20210916132627367" style="zoom:80%;">

<p>典型的字典树问题，我们可以把words中的单词加入到字典树中，然后遍历boards中的每一个节点，进行递归查找。</p>
<p>首先介绍一下字典树吧：</p>
<blockquote>
<p>【字典树】(Trie Tree) 是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串）。<br>它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。<br>                                                    ——百度 · 百科<br>————————————————<br>版权声明：本文为CSDN博主「samarua」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46202073/article/details/107253959">https://blog.csdn.net/m0_46202073/article/details/107253959</a></p>
</blockquote>
<p>就举这题的第一个测试用例的例子吧<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210916133942155.png" alt="image-20210916133942155" style="zoom:80%;"></p>
<p>目前知道的字典树的含义及作用，现在我们来创建字典树</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TrieNode {
    string word;
    unordered_map&lt;int, TrieNode*&gt; children;
    TrieNode(){
        this-&gt;word = "";
    }
}
void insertTrie(TrieNode* root, string word){
    TrieNode* node = root;
    for(char c : word){
        //没有字符c开头的子节点，则创建它
        if(!node-&gt;children.count(c)){
            node-&gt;children[c] = new TrieNode();
        }
        //继续这个单词后面的字符
        node = node-&gt;children[c];
    }
    node-&gt;word = word;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还有一种创建方法，就是用下标表示字母，这个方法就在我上面发的那个链接那看吧</p>
<p>接下来重点就是dfs了，我们每次向四个方向搜索，搜索的节点对应的word长度大于0，说明该路径是一个完整的单词，则加入到set中，set的目的是为了去重，因为不同路径可能有相同的单词。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TrieNode{
    string word;
    unordered_map&lt;char, TrieNode*&gt; children;
    TrieNode(){
        this-&gt;word = "";
    } 
};
void insertTrie(TrieNode* root, const string&amp; word){
    TrieNode* node = root;
    for(char c : word){
        //即node节点下没有这个字符，则创建一个
        if(!node-&gt;children.count(c)){
            node-&gt;children[c] = new TrieNode();
        }
        node = node-&gt;children[c];
    }
    node-&gt;word = word;
}
class Solution {
public:
    int dict[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, TrieNode* root, set&lt;string&gt;&amp; res){
        char c = board[x][y];
        //没有以c为前缀的单词，剪枝
        if(!root-&gt;children.count(c)){
            return false;
        }
        root = root-&gt;children[c];
        if(root-&gt;word.size() &gt; 0){
            res.insert(root-&gt;word);
            root-&gt;word = "";
        }
        board[x][y] = '#';
        for(int i = 0; i &lt; 4; i++){
            int nx = x + dict[i][0];
            int ny = y + dict[i][1];
            if(nx &gt;= 0 &amp;&amp; nx &lt; board.size() &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; board[0].size()){
                if(board[nx][ny] != '#'){
                    dfs(board, nx, ny, root, res);
                }
            }
        }
        board[x][y] = c;
        return true;
    }
    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) {
        set&lt;string&gt; res;
        vector&lt;string&gt; ans;
        TrieNode* root = new TrieNode();
        for(string s : words){
            insertTrie(root, s);
        }
        int n = board.size();
        int m = board[0].size();
        for(int i = 0; i &lt; n; i++){
            for(int j = 0; j &lt; m; j++){
                dfs(board, i, j, root, res);
            }
        }
        for(auto&amp; s : res){
            ans.push_back(s);
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题2：430-扁平化多级双向链表"><a href="#例题2：430-扁平化多级双向链表" class="headerlink" title="例题2：430. 扁平化多级双向链表"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">430. 扁平化多级双向链表</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210924125459392.png" alt="image-20210924125459392" style="zoom:80%;">

<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210924125534400.png" alt="image-20210924125534400" style="zoom:80%;">

<p>dfs就是每个节点搜索到最低处，所以完全适合这题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* prev;
    Node* next;
    Node* child;
};
*/

class Solution {
public:
    Node* flatten(Node* head) {
        dfs(head);
        return head;
    }
    void dfs(Node* node){
        if(node == nullptr){
            return;
        }
        if(node-&gt;child != nullptr){
            //先记录next节点，方便插入到扁平化后的尾节点后面
            Node* next = node-&gt;next;
            //先把子链表扁平化
            dfs(node-&gt;child);
            //修改子节点到node节点的next上
            node-&gt;next = node-&gt;child;
            node-&gt;child-&gt;prev = node;
            //修改完后就要找到子链表的尾节点
            Node* tail = node-&gt;child;
            while(tail-&gt;next != nullptr){
                tail = tail-&gt;next;
            }
            //把先前存的next指针插到tail后面
            if(next != nullptr){
                next-&gt;prev = tail;
            }
            tail-&gt;next = next;
            //最后把node的子链表置空
            node-&gt;child = nullptr;
            //这题这里其实不需要加，因为每层只有一个child，但是当有多个的时候就需要了
            dfs(next);
        }
        else{
            dfs(node-&gt;next);
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="BFS（广度优先搜索）"><a href="#BFS（广度优先搜索）" class="headerlink" title="BFS（广度优先搜索）"></a>BFS（广度优先搜索）</h2><h3 id="例题1：733-图像渲染"><a href="#例题1：733-图像渲染" class="headerlink" title="例题1：733. 图像渲染"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flood-fill/">733. 图像渲染</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210721222805758.png" alt="image-20210721222805758" style="zoom:80%;">

<p>这题我是用到广度优先搜索BFS算法，说说我的思路吧：</p>
<ol>
<li>首先先定义一个队列q来进来节点，和一个set集合visited来记录遍历过的节点</li>
<li>把起点加入q和visited</li>
<li>进入while循环直到q为空</li>
<li>在外循环中，求q中节点个数n，然会进入内循环</li>
<li>在内循环中，我们先把该节点染色，然后遍历该节点的周围节点，把符合要求的加入进来<ol>
<li>符合边界要求</li>
<li>符合未被遍历的要求，即visited中没有该节点</li>
<li>符合该节点的颜色等于起点节点的颜色</li>
</ol>
</li>
<li>外循环结束，返回image</li>
</ol>
<p><strong>代码如下：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) {
        queue&lt;pair&lt;int,int&gt;&gt; q;
        //记录走过的节点
        set&lt;pair&lt;int,int&gt;&gt; visited;
        
        //记录起点
        q.push(make_pair(sr,sc));
        visited.insert(make_pair(sr,sc));
        int high = image.size();
        int wide = image[0].size();
        //因为起点被染色了，所以需要先记录需要染色的颜色信息
        int oldcolor = image[sr][sc];
        while(!q.empty()){
            int n = q.size();
            for(int i = 0; i &lt; n; i++){
                //这里需要判断是否到达终点吗？既然是全部涂色，应该是全部都遍历到吧，所以不需要判断是否是终点
                //所以就把周围节点加入进来
                pair&lt;int,int&gt; cur;
                cur = q.front();
                q.pop();
                image[cur.first][cur.second] = newColor;
                //上节点
                if(cur.first &gt; 0 &amp;&amp; !visited.count(make_pair(cur.first - 1, cur.second))){
                    if(image[cur.first - 1][cur.second] == oldcolor){
                        q.push(make_pair(cur.first - 1, cur.second));
                        visited.insert(make_pair(cur.first - 1, cur.second));
                    }
                }
                //下节点
                if(cur.first&lt;high-1 &amp;&amp; !visited.count(make_pair(cur.first+1, cur.second))){
                    if(image[cur.first + 1][cur.second] == oldcolor){
                        q.push(make_pair(cur.first + 1, cur.second));
                        visited.insert(make_pair(cur.first + 1, cur.second));
                    }
                }
                //左节点
                if(cur.second &gt; 0 &amp;&amp; !visited.count(make_pair(cur.first, cur.second - 1))){
                    if(image[cur.first][cur.second - 1] == oldcolor){
                        q.push(make_pair(cur.first, cur.second - 1));
                        visited.insert(make_pair(cur.first, cur.second - 1)); 
                    }
                }
                //右节点
                if(cur.second&lt;wide-1 &amp;&amp; !visited.count(make_pair(cur.first,cur.second+1))){
                    if(image[cur.first][cur.second + 1] == oldcolor){
                        q.push(make_pair(cur.first, cur.second + 1));
                        visited.insert(make_pair(cur.first, cur.second + 1)); 
                    }
                }
            }
        }
        return image;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题2：695-岛屿的最大面积"><a href="#例题2：695-岛屿的最大面积" class="headerlink" title="例题2：695. 岛屿的最大面积"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210724152408844.png" alt="image-20210724152408844" style="zoom:80%;">

<p>这题可以用到BFS，我们遍历整个地图，直到全部遍历完</p>
<p><strong>在加入右节点那我犯了一个很哭笑不得的错误，把m写成了n，导致一直出错，找了半天的错误，太不应该了。不过吸取教训，下次注意吧。</strong></p>
<ol>
<li>遇到0就跳过，或者遍历过的也跳过</li>
<li>没有超边界，等于1并且没有遍历过，就+1并且加入队列和集合中</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        //这题应该也可以用BFS
        queue&lt;pair&lt;int, int&gt;&gt; q;
        set&lt;pair&lt;int, int&gt;&gt; visited;

        int n = grid.size();
        int m = grid[0].size();
        int max_cnt = 0;
        for(int i = 0; i &lt; n; i++){
            for(int j = 0; j &lt; m; j++){
                if(grid[i][j] == 0 || visited.count(make_pair(i, j))) continue;
                q.push(make_pair(i, j));
                visited.insert(make_pair(i, j));
                //记录每个该节点附近岛屿面积
                int cnt = 1;
                while(!q.empty()){
                    int sz = q.size();
                    for(int k = 0; k &lt; sz; k++){
                        //这里应该也不需要判断是否到达终点，遍历完就行了
                        pair&lt;int, int&gt; cur = q.front();
                        q.pop();
                        int row = cur.first;
                        int col = cur.second;
                        //把周围节点加入进来
                        //上节点
                        if(row &gt; 0 &amp;&amp; grid[row - 1][col] == 1){
                            if(!visited.count(make_pair(row - 1, col))){
                                cnt++;
                                q.push(make_pair(row - 1, col));
                                visited.insert(make_pair(row - 1, col));
                            }
                        }
                        //下节点
                        if(row &lt; n - 1 &amp;&amp; grid[row + 1][col] == 1){
                            if(!visited.count(make_pair(row + 1, col))){
                                cnt++;
                                q.push(make_pair(row + 1, col));
                                visited.insert(make_pair(row + 1, col)); 
                            } 
                        }
                        //左节点
                        if(col &gt; 0 &amp;&amp; grid[row][col - 1] == 1){
                            
                            if(!visited.count(make_pair(row, col - 1))){
                                cnt++;
                                q.push(make_pair(row, col - 1));
                                visited.insert(make_pair(row, col - 1)); 
                            }  
                        }
                        //右节点
                        //这里我把m写成了n，导致我花了好长时间找错误，太不小心了
                        if(col &lt; m - 1 &amp;&amp; grid[row][col + 1] == 1){
                            if(!visited.count(make_pair(row, col + 1))){
                                cnt++;
                                q.push(make_pair(row, col + 1));
                                visited.insert(make_pair(row, col + 1));
                            }   
                        }
                    }
                }
                max_cnt = max(max_cnt, cnt);
            }
        }
        return max_cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题3：847-访问所有节点的最短路径"><a href="#例题3：847-访问所有节点的最短路径" class="headerlink" title="例题3：847. 访问所有节点的最短路径"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/">847. 访问所有节点的最短路径</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210806114539857.png" alt="image-20210806114539857" style="zoom:80%;">

<p>这题和以往的BFS算法题不同，它需要你遍历所有的点，可以重复，所以我们需要记录遍历的状态，因为ｎ＜＝１２，</p>
<p>所以我们就可以使用状态压缩来记录状态。例如：</p>
<blockquote>
<p>０节点遍历，１２３没有，则为（０００１）＝１</p>
<p>０，１节点遍历，２，３没有，则为（００１１）＝３</p>
</blockquote>
<p>所以最终都遍历到时状态表示为１＜＜ｎ－１</p>
<p>而且对于 i  节点：当前状态：state = (1&lt;&lt;i) &amp; mask</p>
<p>​                           改变状态为1：mask = (1&lt;&lt;i) | mask</p>
<p>当然我们还需要一个二维数组来记录该节点的某一状态是否遍历过</p>
<p>有一个题解写的也很不错  </p>
<p>作者：GTAlgorithm<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/solution/gtalgorithm-tu-jie-fa-ba-hardbian-cheng-v5knb/">https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/solution/gtalgorithm-tu-jie-fa-ba-hardbian-cheng-v5knb/</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
        //BFS + 状态压缩
        int n = graph.size();
        //存入的三个元素分别位 id mask dist
        queue&lt;tuple&lt;int, int, int&gt;&gt; q;
        //表示节点为 id  某一状态是否被访问
        vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(1 &lt;&lt; n));
        for(int i = 0; i &lt; n; i++){
            q.push({i, 1 &lt;&lt; i, 0});
            visited[i][1 &lt;&lt; i] = true;
        }
        while(!q.empty()){
            auto[cur, mask, dist] = q.front();
            q.pop();
            if(mask == (1 &lt;&lt; n) - 1) return dist;
            for(int x : graph[cur]){
                //下一状态
                int nextmask = mask | (1 &lt;&lt; x);
                if(!visited[x][nextmask]){
                    q.push({x, nextmask, dist + 1});
                    visited[x][nextmask] = true;
                }
            }
        }
        return 0;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题4：200-岛屿数量"><a href="#例题4：200-岛屿数量" class="headerlink" title="例题4：200. 岛屿数量"></a>例题4：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210806224725365.png" alt="image-20210806224725365" style="zoom:80%;">

<p>这题<strong>例题2</strong>很类似，都是遍历整个二维数组，然后记录隔开的岛屿有几个，<strong>一个岛屿必须是被水包围的</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        int n = grid.size();
        int m = grid[0].size();
        queue&lt;pair&lt;int, int&gt;&gt; q;
        set&lt;pair&lt;int, int&gt;&gt; visited;
        int cnt = 0;
        for(int i = 0; i &lt; n; i++){
            for(int j = 0; j &lt; m; j++){
                if(grid[i][j] == '1' &amp;&amp; !visited.count(make_pair(i, j))){
                    q.push(make_pair(i, j));
                    visited.insert(make_pair(i, j));
                    cnt++;
                }
                while(!q.empty()){
                    auto [x, y] = q.front();
                    q.pop();
                    //把周围未访问的陆地加入进来
                    //上节点
                    if(x &gt; 0 &amp;&amp; grid[x - 1][y] == '1' &amp;&amp; !visited.count(make_pair(x -1, y))){
                        q.push(make_pair(x - 1, y));
                        visited.insert(make_pair(x - 1, y));
                    }
                    //下节点
                    if(x &lt; n -1 &amp;&amp; grid[x+1][y] == '1' &amp;&amp; !visited.count(make_pair(x+1, y))){
                        q.push(make_pair(x + 1, y));
                        visited.insert(make_pair(x + 1, y));
                    }
                    //左节点
                    if(y &gt; 0 &amp;&amp; grid[x][y -1] == '1' &amp;&amp; !visited.count(make_pair(x, y - 1))){
                        q.push(make_pair(x, y -1));
                        visited.insert(make_pair(x, y - 1));
                    }
                    //右节点
                    if(y &lt; m -1 &amp;&amp; grid[x][y+1] == '1' &amp;&amp; !visited.count(make_pair(x, y+1))){
                        q.push(make_pair(x, y + 1));
                        visited.insert(make_pair(x, y + 1));
                    }
                }
            }
        }
        return cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题5：130-被围绕的区域"><a href="#例题5：130-被围绕的区域" class="headerlink" title="例题5：130. 被围绕的区域"></a>例题5：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210810171652435.png" alt="image-20210810171652435" style="zoom:80%;">

<p>这个题目典型的BFS了，老BFS了。我们可以从边界处的O入手，然后记录与边界O相连的O，最后遍历整个图，把没有记录的O换成X就行了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        int n = board.size();
        int m = board[0].size();
        queue&lt;pair&lt;int, int&gt;&gt; q;
        set&lt;pair&lt;int, int&gt;&gt; visited;
        //从边界处为O的地方开始，把与它相连的O换成X就行了
        for(int i = 0; i &lt; m; i++){
            if(board[0][i] == 'O'){
                q.push(make_pair(0, i));
                visited.insert(make_pair(0, i));
            }
            if(board[n - 1][i] == 'O'){
                q.push(make_pair(n - 1, i));
                visited.insert(make_pair(n - 1, i));
            }
        }
        for(int i = 1; i &lt; n - 1; i++){
            if(board[i][0] == 'O'){
                q.push(make_pair(i , 0));
                visited.insert(make_pair(i, 0));
            }
            if(board[i][m - 1] == 'O'){
                q.push(make_pair(i, m - 1));
                visited.insert(make_pair(i, m - 1));
            }
        }
        //开始遍历与边界O相连的O
        while(!q.empty()){
            pair&lt;int, int&gt; cur = q.front();
            q.pop();
            int x = cur.first;
            int y = cur.second;
            //开始遍历周围节点
            //上节点
            if(x &gt; 0 &amp;&amp; board[x - 1][y] == 'O' &amp;&amp; !visited.count(make_pair(x - 1, y))){
                q.push(make_pair(x - 1, y));
                visited.insert(make_pair(x - 1, y));
            }
            //下节点
            if(x &lt; n - 1 &amp;&amp; board[x + 1][y] == 'O' &amp;&amp; !visited.count(make_pair(x + 1, y))){
                q.push(make_pair(x + 1, y));
                visited.insert(make_pair(x + 1, y));
            }
            //左节点
            if(y &gt; 0 &amp;&amp; board[x][y - 1] == 'O' &amp;&amp; !visited.count(make_pair(x, y - 1))){
                q.push(make_pair(x, y - 1));
                visited.insert(make_pair(x, y - 1));
            }
            //右节点
            if(y &lt; m - 1 &amp;&amp; board[x][y + 1] == 'O' &amp;&amp; !visited.count(make_pair(x, y + 1))){
                q.push(make_pair(x, y + 1));
                visited.insert(make_pair(x, y + 1));
            }
        }
        for(int i = 0; i &lt; n; i++){
            for(int j = 0; j &lt; m; j++){
                if(board[i][j] == 'O' &amp;&amp; !visited.count(make_pair(i, j))){
                    board[i][j] = 'X';
                }
            }
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题6：LCP-45-自行车炫技赛场"><a href="#例题6：LCP-45-自行车炫技赛场" class="headerlink" title="例题6：LCP 45. 自行车炫技赛场"></a>例题6：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kplEvH/">LCP 45. 自行车炫技赛场</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210925211416788.png" alt="image-20210925211416788" style="zoom:80%;">

<p>这题和平常的BFS差不多，不过可以走回头路，我们必须要记录走到(x, y)处，速度为 v 时的这个状态，防止下次再走，所以也就是多开一个数组进行记录。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int dict[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    vector&lt;vector&lt;int&gt;&gt; bicycleYard(vector&lt;int&gt;&amp; position, vector&lt;vector&lt;int&gt;&gt;&amp; terrain, vector&lt;vector&lt;int&gt;&gt;&amp; obstacle) {
        queue&lt;tuple&lt;int, int, int&gt;&gt; q;
        q.push({position[0], position[1], 1});
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;vector&lt;bool&gt;&gt; used(101, vector&lt;bool&gt;(101, false));
        used[position[0]][position[1]] = true;
        while(!q.empty()){
            tuple&lt;int, int, int&gt; cur = q.front();
            q.pop();
            for(auto&amp; dir : dict){
                //这是下一节点的位置
                int x0 = get&lt;0&gt;(cur), y0 = get&lt;1&gt;(cur);
                int x = get&lt;0&gt;(cur) + dir[0];
                int y = get&lt;1&gt;(cur) + dir[1];
                if(x0 &lt; 0 || x0 &gt;= position.size() || y0 &lt; 0 || y0 &gt;= position.size()) continue;
                if(x &lt; 0 || x &gt;= position.size() || y &lt; 0 || y &gt;= position.size()) continue;
                if(used[x][y]) continue; 
                //算速度变化量，如果速度小于0，不加入；如果大于0，可以加入继续搜索
                int spreed = terrain[get&lt;0&gt;(cur)][get&lt;1&gt;(cur)] - terrain[x][y] - obstacle[x][y];
                if(get&lt;2&gt;(cur) - spreed == 1) res.push_back({x, y});
                if(get&lt;2&gt;(cur) - spreed &gt; 0){
                    q.push({x, y, get&lt;2&gt;(cur) - spreed});
                    used[x][y] = true;
                }
            }
        }
        sort(res.begin(), res.end(), cmp);
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="例题1：743-网络延迟时间"><a href="#例题1：743-网络延迟时间" class="headerlink" title="例题1：743. 网络延迟时间"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210805105604017.png" alt="image-20210805105604017" style="zoom:80%;">

<p><strong>方法一</strong>：Flyod算法，时间复杂度为O(n^3)，先把该节点转换成邻接矩阵，然后使用Flyod算法求最短路径，然后从源点到各个节点的距离的最大值就是答案的解。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {
        //方法一:Flyod算法
        int inf = INT_MAX / 2;
        vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(n, inf));
        for(auto&amp; u: times){
            int x = u[0] - 1;
            int y = u[1] - 1;
            grid[x][y] = u[2];
        }
        for(int i = 0; i &lt; n; i++){
            for(int j = 0; j &lt; n; j++){
                if(i == j) grid[i][j] = 0;
            }
        }
        //到此有向图的邻接矩阵创建完毕

        //开始寻找最短路径
        for(int p = 0; p &lt; n; p++){
            for(int i = 0; i &lt; n; i++){
                for(int j = 0; j &lt; n; j++){
                    grid[i][j] = min(grid[i][j], grid[i][p] + grid[p][j]);
                }
            }
        }
        int ans = 0;
        for(int i = 0; i &lt; n; i++){
            ans = max(ans, grid[k - 1][i]);
        }
        return ans &gt; inf / 2 ? -1 : ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>方法二</strong>：Dijkstra算法，详细步骤我写在代码中了</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {
        //方法二：Dijkstra算法
        /*
            1.我们先把节点转换成有向图的邻接矩阵
            2.需要一个used 数组来记录已经求好了最短路径的节点
            3.还需要一个dist 数组来记录到源点的距离
            4.每次选取最短的点记为x，然后用 x 来更新其余未更新的节点到源点的最短距离
        */
        const int inf = INT_MAX / 2;
        vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(n, inf));
        for(auto&amp; u : times){
            int x = u[0] - 1;
            int y = u[1] - 1;
            grid[x][y] = u[2]; 
        }
        //创建dist数组来记录源点到个节点的距离
        vector&lt;int&gt; dist(n,inf);
        dist[k - 1] = 0;
        //创建used数组来记录已经更新过的节点
        vector&lt;bool&gt; used(n);
        for(int i = 0; i &lt; n; i++){
            int x = -1;
            //找到最小值，标记为x
            for(int y = 0; y &lt; n; y++){
                if(!used[y] &amp;&amp; (x == -1 || dist[y] &lt; dist[x])){
                    x = y;
                }
            }
            //该节点以使用，把x加入used数组
            used[x] = true;
            //用x来进行更新其它节点到源点的距离
            for(int y = 0; y &lt; n; y++){
                dist[y] = min(dist[y], dist[x] + grid[x][y]); 
            }
        }
        int ans = *max_element(dist.begin(), dist.end());
        return ans == inf ? -1 : ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题2：1091-二进制矩阵中的最短路径"><a href="#例题2：1091-二进制矩阵中的最短路径" class="headerlink" title="例题2：1091. 二进制矩阵中的最短路径"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210810164250501.png" alt="image-20210810164250501" style="zoom:80%;">

<p>这题和普通的图的最短路径还是有些不同的，这个没有给你哪个节点可以到达哪个节点，所以我们还是不能使用Floyd和Dijkstra算法，直接用BFS就行了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int n = grid.size();
        if(n == 1 &amp;&amp; grid[0][0] == 0) return 1;
        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;
        queue&lt;pair&lt;int, int&gt;&gt; q;
        set&lt;pair&lt;int, int&gt;&gt; visited;
        //把起点加入队列中，起点为(0, 0)
        q.push(make_pair(0 , 0));
        visited.insert(make_pair(0, 0));
        //走过的单元格
        int ans = 1;
        int cnt = 1;
        while(!q.empty()){
            pair&lt;int, int&gt; cur = q.front();
            q.pop();
            cnt--;
            int x = cur.first;
            int y = cur.second;
            //判断下一个是否就是终点
            if(x == n - 2 &amp;&amp; y == n - 2) return ans + 1;
            if(x == n - 1 &amp;&amp; y == n - 2) return ans + 1;
            if(x == n - 2 &amp;&amp; y == n - 1) return ans + 1; 
            //把周围节点加入进来
            for(int k = - 1; k &lt; 2; k += 2){
                //上下节点
                if(x + k &gt;= 0 &amp;&amp; x + k &lt; n &amp;&amp; grid[x + k][y] == 0){
                    if(!visited.count(make_pair(x + k, y))){
                        q.push(make_pair(x + k, y));
                        visited.insert(make_pair(x + k, y));
                    }
                }
                //左右节点
                if(y + k &gt;= 0 &amp;&amp; y + k &lt; n &amp;&amp; grid[x][y + k] == 0){
                    if(!visited.count(make_pair(x, y + k))){
                        q.push(make_pair(x, y + k));
                        visited.insert(make_pair(x, y + k));
                    }
                }
                //左上右下
                if(x + k &gt;= 0 &amp;&amp; x + k &lt; n &amp;&amp; y + k &gt;= 0 &amp;&amp; y + k &lt; n){
                    if(grid[x + k][y + k] == 0 &amp;&amp; !visited.count(make_pair(x + k, y + k ))){
                        q.push(make_pair(x + k, y + k));
                        visited.insert(make_pair(x + k, y + k));
                    }
                }
                //左下右上
                if(x - k &gt;= 0 &amp;&amp; x - k &lt; n &amp;&amp; y + k &gt;= 0 &amp;&amp; y + k &lt; n){
                    if(grid[x - k][y + k] == 0 &amp;&amp; !visited.count(make_pair(x - k, y + k ))){
                        q.push(make_pair(x - k, y + k));
                        visited.insert(make_pair(x - k, y + k));
                    }
                }
            }
            //这里是关键，当cnt = 0时，表明已经寻找完周围一层了，这时候路径加一
            if(cnt == 0){
                ans++;
                cnt = q.size();
            }
        }
        return - 1;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题3：787-K-站中转内最便宜的航班"><a href="#例题3：787-K-站中转内最便宜的航班" class="headerlink" title="例题3：787. K 站中转内最便宜的航班"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">787. K 站中转内最便宜的航班</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210825190511875.png" alt="image-20210825190511875" style="zoom:80%;">

<p>这题还是很有难度的，我们可以使用BFS+Dijkstra算法，这就是带权的最短路问题</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) {
        //储存src到该点的距离即费用
        queue&lt;pair&lt;int, int&gt;&gt; q;
        unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; graph;
        q.push({src, 0});
        for(auto&amp; flight : flights){
            graph[flight[0]][flight[1]] = flight[2];
        }
        //源点到每个点的距离
        vector&lt;int&gt; dist(n, INT_MAX);
        dist[src] = 0;
        //总的费用
        int ans = -1;
        //经过的站的数量
        int step = 0;
        while(!q.empty() &amp;&amp; step &lt;= k + 1){
            int sz = q.size();
            while(sz){
                auto [node, distance] = q.front();
                q.pop();
                sz--;
                if(node == dst &amp;&amp; (ans == -1 || ans &gt; distance)){
                    ans = distance;
                    continue;
                }
                //更新一下源点到节点的距离
                for(auto [next, distance0] : graph[node]){
                    if(dist[next] &gt; distance + distance0){
                        dist[next] = distance + distance0;
                        q.push({next, dist[next]});
                    }
                }
            }
            step++;
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还有动态规划的做法，不够比较难想</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) {
        //表示从src到i最多经过k站所花费的最少费用
        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(k + 2, INT_MAX));
        for(int i = 0; i &lt;= k + 1; i++){
            dp[src][i] = 0;
        }
        for(int i = 1; i &lt;= k + 1; i++){
            for(vector&lt;int&gt;&amp; flight : flights){
                if(dp[flight[0]][i - 1] != INT_MAX){
                    dp[flight[1]][i] = min(dp[flight[1]][i], dp[flight[0]][i - 1] + flight[2]);
                }
            }
        }
        return dp[dst][k + 1] == INT_MAX ? -1 : dp[dst][k + 1];
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="拓扑排序（图中是否有环）"><a href="#拓扑排序（图中是否有环）" class="headerlink" title="拓扑排序（图中是否有环）"></a>拓扑排序（图中是否有环）</h3><p><strong>拓扑排序其实就是一个BFS过程，找到没有环的节点</strong></p>
<h4 id="例题1：802-找到最终的安全状态"><a href="#例题1：802-找到最终的安全状态" class="headerlink" title="例题1：802. 找到最终的安全状态"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210805120225127.png" alt="image-20210805120225127" style="zoom:80%;">

<p>逆拓扑排序，也就是把图的方向反一下就行了，具体步骤我写在了代码中</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; eventualSafeNodes(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
        //逆拓扑排序，拓扑排序是入度为0的节点指向的节点进行排序的，而这题是反过来
        //1. 创建邻接表存储每个节点的指向的节点
        int n = graph.size();
        vector&lt;vector&lt;int&gt;&gt; grid(n);
        //2. 记录节点的入度
        vector&lt;int&gt; indeg(n , 0);
        for(int i = 0; i &lt; n; i++){
            for(auto&amp; u : graph[i]){
                //反过来，因为题目是求出度为0
                grid[u].push_back(i);
            }
            //原数组记录的是出度，在反图中记录的就是入度
            indeg[i] = graph[i].size();
        }

        //进行排序
        queue&lt;int&gt; q;
        //3. 把入度为0的节点纳入队列中
        for(int i = 0; i &lt; n; i++){
            if(!indeg[i]){
                q.push(i);
            }
        }
        //4. 出队列，把该节点的指向节点的入度都减 1，然后判断算法为入度为0的节点，若是则加入队列中
        while(!q.empty()){
            //出队列
            int cur = q.front();
            q.pop();
            //该节点的指向节点的入度都减1
            for(int&amp; x : grid[cur]){
                indeg[x]--;
                //若入度为0，则加入队列中
                if(!indeg[x]){
                    q.push(x);
                }
            }
        }
        //入度为0的点就是安全点
        vector&lt;int&gt; points;
        for(int i = 0; i &lt; n; i++){
            if(!indeg[i]){
                points.push_back(i);
            }
        }
        sort(points.begin(), points.end());
        return points;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题2：457-环形数组是否存在循环"><a href="#例题2：457-环形数组是否存在循环" class="headerlink" title="例题2：457. 环形数组是否存在循环"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/circular-array-loop/">457. 环形数组是否存在循环</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210807142803142.png" alt="image-20210807142803142" style="zoom:80%;">

<p><strong>方法一：拓扑排序</strong></p>
<p>拓扑排序解决哪些寻求图中是否有环的题，这题可以转换成图中是否存在非自环的问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    //创建邻接矩阵表
    vector&lt;vector&lt;int&gt;&gt; graph;
    //创建入度数组
    vector&lt;int&gt; Indeg;

    bool topoSort(int n){
        queue&lt;int&gt; q;
        //把入度为0的节点加入队列中
        for(int i = 0; i &lt; n; i++){
            if(!Indeg[i])
                q.push(i);
        }
        //开始去掉入度为0的节点连接的边，并加入新的节点到队列中
        while(!q.empty()){
            int cur = q.front();
            q.pop();
            for(int&amp; end : graph[cur]){
                Indeg[end]--;
                if(!Indeg[end]){
                    q.push(end);
                }
            }
        }
        //判断排序后是否还存在入度不为0的节点
        for(int i = 0; i &lt; n; i++){
            if(Indeg[i]){
                return true;
            }
        }
        return false;
    }
    bool circularArrayLoop(vector&lt;int&gt;&amp; nums) {
        //可以采用拓扑排序的方法进行解答
        int n = nums.size();
        graph.resize(n);
        Indeg.resize(n);
        //先处理nums[i] &gt; 0 的节点
        for(int i = 0; i &lt; n; i++){
            int end = ((i + nums[i]) % n + n) % n;
            //这里i == end是处理自环的
            if(nums[i] &lt;= 0 || i == end) continue;
            graph[i].push_back(end);
            Indeg[end]++;
        }
        if(topoSort(n)) return true;
        //清除前面的数据，开始处理nums[i] &lt; 0的节点
        graph.clear();
        graph.resize(n);
        Indeg.clear();
        Indeg.resize(n);

        for(int i = 0; i &lt; n; i++){
            int end = ((i + nums[i]) % n + n) % n;
            if(nums[i] &gt;= 0 || i == end) continue;
            graph[i].push_back(end);
            Indeg[end]++;
        }
        if(topoSort(n)) return true;
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>方法二：双指针</strong></p>
<p>每次slow指向下一个，fast指针指向下下一个，然后遍历完一个节点后就把它及移动遇到的节点标记，防止下次重复遍历。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    bool circularArrayLoop(vector&lt;int&gt;&amp; nums) {
        //这题也可以看成链表中是否存在环的问题，转换成链表问题
        int n = nums.size();
        //这种写法没怎么写过，不过感觉还挺不错的
        auto next = [&amp;](int cur){
            //保证在[0, n)内
            return ((cur + nums[cur]) % n + n) % n;
        };
        for(int i = 0; i &lt; n; i++){
            if(!nums[i]) continue;
            int slow = i, fast = next(i);
            //保证是单向边
            while(nums[slow]*nums[fast] &gt; 0 &amp;&amp; nums[slow]*nums[next(fast)] &gt; 0){
                if(slow == fast){
                    //防止 k = 1
                    if(slow != next(slow))
                        return true;
                    else
                        break;
                }
                slow = next(slow);
                fast = next(next(fast));
            }
            //标记遍历过的节点
            int add = i;
            while(nums[add] * nums[next(add)] &gt; 0){
                nums[add] = 0;
                add = next(add);
            }
        }
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题3：5909-并行课程-III"><a href="#例题3：5909-并行课程-III" class="headerlink" title="例题3：5909. 并行课程 III"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/parallel-courses-iii/">5909. 并行课程 III</a></h4><p>这题在下面的第264场周赛有解释，很经典的拓扑排序题，或者说就是纯拓扑排序的题。</p>
<h3 id="无向连通图"><a href="#无向连通图" class="headerlink" title="无向连通图"></a>无向连通图</h3><h4 id="例题1：547-省份数量"><a href="#例题1：547-省份数量" class="headerlink" title="例题1：547. 省份数量"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210807114139944.png" alt="image-20210807114139944" style="zoom:80%;">

<p>这题就是求无向连通图的个数，可以使用BFS和并查集来解决此题。</p>
<p><strong>方法一：BFS</strong></p>
<ol>
<li>我们遍历此图的n各节点，先判断此节点是否已经被访问了，如果没有转到2</li>
<li>加入队列并标记已访问，这是一个新的连通图，然后再把与它连通的节点加入队列并标记</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) {
        int n = isConnected.size();
        //求连通的数量
        queue&lt;int&gt; q;
        vector&lt;bool&gt; visited(n, false);
        int cnt = 0;     
        for(int i = 0; i &lt; n; i++){
            //如果该点未被访问，则说明是一个新的连通图，然后把连通的节点都加入进来
            if(!visited[i]){
                q.push(i);
                visited[i] = true;
                cnt++;
                while(!q.empty()){
                    int cur = q.front();
                    q.pop();
                    for(int j = 0; j &lt; n; j++){
                        if(isConnected[cur][j] == 1 &amp;&amp; !visited[j]){
                            q.push(j);
                            visited[j] = true;
                        }
                    }
                }
            }
        }
        return cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>方法二：并查集</strong></p>
<p>如果不熟悉并查集可以看看我的这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wzy1414/article/details/112497830">并查集_wzy1414的博客-CSDN博客</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class UnionFind{
    private:
        vector&lt;int&gt; parent;
        vector&lt;int&gt; size;
        int count;
    public:
        UnionFind(int n){
            parent.resize(n);
            size.resize(n);
            count = n;
            for(int i = 0; i &lt; n; i++){
                parent[i] = i;
                size[i] = 1; 
            }
        }
        //查找 x 的祖先
        int Find(int x){
            while(x != parent[x]){
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }
        //合并节点
        void Union(int x, int y){
            int root_x = Find(x);
            int root_y = Find(y);
            if(root_x == root_y)
                return;
            if(size[root_x] &gt; size[root_y]){
                //把小的接到大的后面
                parent[root_y] = root_x;
                size[root_x] += size[root_y];
            }
            else{
                parent[root_x] = root_y;
                size[root_y] += size[root_x];
            }
            count--;
        }
        int getCount(){
            return count;
        }
};
class Solution {
public:
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) {
        int n = isConnected.size();
        //c++中new返回的是一个指针，所以前面得加一个*
        UnionFind* uf = new UnionFind(n);
        //遍历每个节点
        for(int i = 0; i &lt; n; i++){
            for(int j = 0; j &lt; n; j++){
                if(isConnected[i][j] == 1){
                    uf-&gt;Union(i, j);
                }
            }
        }
        return uf-&gt;getCount();
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><h4 id="例题1：797-所有可能的路径"><a href="#例题1：797-所有可能的路径" class="headerlink" title="例题1：797. 所有可能的路径"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210810193041485.png" alt="image-20210810193041485" style="zoom:80%;">

<p>这题用DFS做可能会简单很多，但目前我还不是很会DFS，所以这里我用的BFS。</p>
<p>方法和普通套路差不多，只不过要回退</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
        int n = graph.size();
        queue&lt;vector&lt;int&gt;&gt; q;
        vector&lt;vector&lt;int&gt;&gt; res;
        q.push({0});
        while(!q.empty()){
            vector&lt;int&gt; cur = q.front();
            q.pop();
            //cur数组中最后元素连接下一个路径
            int m = cur[cur.size() - 1];
            for(int i = 0; i &lt; graph[m].size(); i++){
                cur.push_back(graph[m][i]);
                if(graph[m][i] == n - 1){
                    res.push_back(cur);
                }
                q.push(cur);
                //回退一个，再加入剩下的几个
                cur.pop_back();
            }
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>开始二叉树肯定得把二叉树的几个遍历写出来吧 b（￣▽￣）d</p>
<p><strong>前序遍历（递归）：</strong></p>
<p>递归也就是熟知的DFS</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        traversal(root, res);
        return res;
    }
    void traversal(TreeNode* node, vector&lt;int&gt;&amp; res){
        if(node == nullptr) return;
        res.push_back(node-&gt;val);
        traversal(node-&gt;left, res);
        traversal(node-&gt;right, res);
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>前序遍历（迭代）：</strong>　</p>
<p>迭代就是用栈来实现递归，因为递归就是利用栈来实现的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        if(root == nullptr) return res;
        stack&lt;TreeNode*&gt; st;
        st.push(root);
        while(!st.empty()){
            TreeNode* cur = st.top();
            st.pop();
            res.push_back(cur-&gt;val);
            if(cur-&gt;right) st.push(cur-&gt;right);
            if(cur-&gt;left) st.push(cur-&gt;left);
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>中序遍历（递归）：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        traversal(root, res);
        return res;
    }
    void traversal(TreeNode* node, vector&lt;int&gt;&amp; res){
        if(node == nullptr) return;
        traversal(node-&gt;left, res);
        res.push_back(node-&gt;val);
        traversal(node-&gt;right, res);
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>中序遍历（迭代）：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        if(root == nullptr) return res;
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur = root;
        while(cur != nullptr || !st.empty()){
            if(cur != nullptr){
                //一直访问左节点
                st.push(cur);
                cur = cur-&gt;left;
            }
            else{
                //左节点访问结束
                cur = st.top();
                st.pop();
                //访问中节点
                res.push_back(cur-&gt;val);
                //访问右节点
                cur = cur-&gt;right;
            }
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>后序遍历（递归）：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        traversal(root, res);
        return res;
    }
    void traversal(TreeNode* node, vector&lt;int&gt;&amp; res){
        if(node == nullptr) return;
        traversal(node-&gt;left, res);
        traversal(node-&gt;right, res);
        res.push_back(node-&gt;val);
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>后序遍历（迭代）：</strong></p>
<p>其实这里的后序遍历的迭代过程和前续遍历迭代差不多，就是最后把数组反转一下。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; st;
        if(root != nullptr) st.push(root);
        while(!st.empty()){
            TreeNode* cur = st.top();
            st.pop();
            //我们要求的顺序为左右中，这里我们是中右左，最后反转就行了
            res.push_back(cur-&gt;val);
            //因为栈是先进后出，所以我们得先让左进去
            if(cur-&gt;left) st.push(cur-&gt;left);
            if(cur-&gt;right) st.push(cur-&gt;right);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>看来个博主的文章，迭代还有个统一的写法，不过可能较难理解。我们可以用NULL来进行标记“中”，只有遇到NULL时，才把下一个节点的数值放入到数组中，这样就实现了中节点的访问顺序和处理顺序一致。</p>
<p>这里我就写个中序的统一的迭代形式，其它的就是换一下就行了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; st;
        if(root != nullptr) st.push(root);
        while(!st.empty()){
            TreeNode* cur = st.top();
            //如果不是空节点，那么就继续放入节点
            if(cur != nullptr){
                //排除，防止重复
                st.pop();
                //这里的顺序就比较友善了，不过因为是栈，所以得反过来
                if(cur-&gt;right) st.push(cur-&gt;right);
                st.push(cur);
                st.push(nullptr);
                if(cur-&gt;left) st.push(cur-&gt;left);
            }
            else{
                st.pop();
                cur = st.top();
                st.pop();
                res.push_back(cur-&gt;val);
            }
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>二叉树的层序遍历：</strong></p>
<p>层序遍历其实就是BFS。这里还分了组，如果不分组的话，就不需要 sz 了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; ans;
        queue&lt;TreeNode*&gt; q;
        if(root != nullptr) q.push(root);
        while(!q.empty()){
            int sz = q.size();
            ans.clear();
            for(int i = 0; i &lt; sz; i++){
                TreeNode* cur = q.front();
                q.pop();
                ans.push_back(cur-&gt;val);
                if(cur-&gt;left != nullptr) q.push(cur-&gt;left);
                if(cur-&gt;right != nullptr) q.push(cur-&gt;right);
            }
            res.push_back(ans);
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="例题1：112-路径总和"><a href="#例题1：112-路径总和" class="headerlink" title="例题1：112. 路径总和"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210928130117126.png" alt="image-20210928130117126" style="zoom:80%;">

<p>这题就是搜索整棵树，但是找到一条符合条件的路径后就可以返回了</p>
<p><strong>DFS版：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root ==nullptr) return false;
        return dfs(root, targetSum - root-&gt;val);
    }
    bool dfs(TreeNode* root, int targetSum){
        if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; targetSum == 0){
            return true;
        }
        if(!root-&gt;left &amp;&amp; !root-&gt;right) return false;
        //不把空节点放进去
        if(root-&gt;left){
            if(dfs(root-&gt;left, targetSum - root-&gt;left-&gt;val)) return true;
        }
        if(root-&gt;right){
            if(dfs(root-&gt;right, targetSum- root-&gt;right-&gt;val)) return true;
        }
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>DFS栈实现版：</strong>感觉和BFS实现很像，这里是前序遍历</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class solution {

public:
    bool haspathsum(treenode* root, int sum) {
        if (root == null) return false;
        // 此时栈里要放的是pair&lt;节点指针，路径数值&gt;
        stack&lt;pair&lt;treenode*, int&gt;&gt; st;
        st.push(pair&lt;treenode*, int&gt;(root, root-&gt;val));
        while (!st.empty()) {
            pair&lt;treenode*, int&gt; node = st.top();
            st.pop();
            // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if (!node.first-&gt;left &amp;&amp; !node.first-&gt;right &amp;&amp; sum == node.second) return true;

            // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first-&gt;right) {
                st.push({node.first-&gt;right, node.second + node.first-&gt;right-&gt;val});
            }

            // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first-&gt;left) {
                st.push({node.first-&gt;left, node.second + node.first-&gt;left-&gt;val});
            }
        }
        return false;
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>BFS版：</strong>感觉比DFS快不少啊</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        //BFS我们就需要一个pair来储存节点和当前的和
        if(root == nullptr) return false;
        queue&lt;pair&lt;TreeNode*, int&gt;&gt; q;
        q.push({root, root-&gt;val});
        while(!q.empty()){
            pair&lt;TreeNode*, int&gt; cur = q.front();
            q.pop();
            TreeNode* root0 = cur.first;
            int sum = cur.second;
            if(!root0-&gt;left &amp;&amp; !root0-&gt;right &amp;&amp; sum == targetSum) return true;
            //该节点不是，那么就找子节点
            if(root0-&gt;left){
                q.push({root0-&gt;left, sum + root0-&gt;left-&gt;val});
            }
            if(root0-&gt;right){
                q.push({root0-&gt;right, sum + root0-&gt;right-&gt;val});
            }
        }
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题2：113-路径总和-II"><a href="#例题2：113-路径总和-II" class="headerlink" title="例题2：113. 路径总和 II"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210928131413574.png" alt="image-20210928131413574" style="zoom:80%;">

<p>这题就是要我们遍历整棵树了，找到所有路径，所以不需要返回值。</p>
<p>采用了回溯的方法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; ans;
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return res;
        ans.push_back(root-&gt;val);
        dfs(root, targetSum - root-&gt;val);
        return res;
    }
    void dfs(TreeNode* cur, int targetSum){
        if(!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; targetSum == 0){
            res.push_back(ans);
        }
        if(cur-&gt;left){
            targetSum -= cur-&gt;left-&gt;val;
            ans.push_back(cur-&gt;left-&gt;val);
            dfs(cur-&gt;left, targetSum);
            targetSum += cur-&gt;left-&gt;val;
            ans.pop_back();
        }
        if(cur-&gt;right){
            targetSum -= cur-&gt;right-&gt;val;
            ans.push_back(cur-&gt;right-&gt;val);
            dfs(cur-&gt;right, targetSum);
            targetSum += cur-&gt;right-&gt;val;
            ans.pop_back();
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题3：437-路径总和-III"><a href="#例题3：437-路径总和-III" class="headerlink" title="例题3：437. 路径总和 III"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210928134736000.png" alt="image-20210928134736000" style="zoom:80%;">

<p>这题可以有两种方法，不过第二种我是想不到啊。</p>
<p>第一种，可以用两次DFS，第一次搜索所有的节点，第二个是以这个节点为起点搜索所有路径</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //就遍历每个节点为起点
    int cnt = 0;
    int t;
    int pathSum(TreeNode* root, int targetSum) {
        t = targetSum;
        dfs1(root);
        return cnt;
    }
    void dfs1(TreeNode* root){
        if(root == nullptr) return;
        dfs2(root,root-&gt;val);
        dfs1(root-&gt;left);
        dfs1(root-&gt;right);
    }
    void dfs2(TreeNode* cur, int sum){
        if(sum == t){
            cnt++;
        }
        if(cur-&gt;left){
            dfs2(cur-&gt;left, sum + cur-&gt;left-&gt;val);
        }
        if(cur-&gt;right){
            dfs2(cur-&gt;right, sum + cur-&gt;right-&gt;val);
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第二种就难想了，前缀和加DFS。设当前节点与该路径下前面节点的和为sum ，那么当移动到后面的节点的前缀和为</p>
<p>sum + targetSum时，这就是一条符合条件的路径。</p>
<p>所以我们需要记录当前路径的前面的前缀和的数量</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {
        unordered_map&lt;int, int&gt; hashTable;
        //和为0的路径当前有一条
        hashTable[0] = 1;
        return dfs(root, hashTable, targetSum, 0);
    }
    int dfs(TreeNode* node, unordered_map&lt;int, int&gt; hashTable, int targetSum, int curSum){
        if(node == nullptr) return 0;
        curSum += node-&gt;val;
        int res = 0;
        res += hashTable[curSum - targetSum];
        hashTable[curSum]++;
        //进入下一层
        res += dfs(node-&gt;left, hashTable, targetSum, curSum);
        res += dfs(node-&gt;right, hashTable, targetSum, curSum);
        //回到本层，回复
        hashTable[curSum]--;
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题4：117-填充每个节点的下一个右侧节点指针-II"><a href="#例题4：117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="例题4：117. 填充每个节点的下一个右侧节点指针 II"></a>例题4：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210930195152959.png" alt="image-20210930195152959" style="zoom:80%;">

<p>这题还有个I，不过那个是满二叉树，所以也没啥区别。</p>
<p>如果使用队列来做的话，就很简单了，就是个层序遍历的模板题</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        queue&lt;Node*&gt; q;
        if(root != NULL) q.push(root);
        while(!q.empty()){
            int sz = q.size();
            for(int i = 0; i &lt; sz; i++){
                Node* cur = q.front();
                q.pop();
                if(i == sz - 1) cur-&gt;next = NULL;
                else cur-&gt;next = q.front();
                if(cur-&gt;left) q.push(cur-&gt;left);
                if(cur-&gt;right) q.push(cur-&gt;right);
            } 
        }
        return root;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但题目要求使用常数级别的空间复杂度，所以这里还不能使用队列。通过观察可知，next指针已经把下一层的节点连接成了一个链表，所以我们可以通过这点来进行解答。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    Node* connect(Node* root) {
        if(root == NULL) return root;
        Node* node = root;
        while(node != NULL){
            //设置一个哑节点来当作每一层链表的虚拟头节点，方便后续进入下一层
            Node* dummy = new Node();
            Node* preNode = dummy;
            while(node != NULL){
                if(node-&gt;left){
                    preNode-&gt;next = node-&gt;left;
                    preNode = preNode-&gt;next;
                }
                if(node-&gt;right){
                    preNode-&gt;next= node-&gt;right;
                    preNode = preNode-&gt;next;
                }
                node = node-&gt;next;
            }
            //跳转到下一层
            node = dummy-&gt;next;
        }
        return root;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题5：226-翻转二叉树"><a href="#例题5：226-翻转二叉树" class="headerlink" title="例题5：226. 翻转二叉树"></a>例题5：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210930202928406.png" alt="image-20210930202928406" style="zoom:80%;">

<p>我们可以把这交换后的数并排观察一下</p>
<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210930203122962.png" alt="image-20210930203122962" style="zoom:67%;">

<p>我们发现其实就是把每个节点的左右子树交换就行了，关键是用前中后哪个遍历呢？</p>
<p>答案公布：前后都可以，但中序不行。因为中序遍历左子树反转两次，右子树没有反转。自己画图试一下就很清楚了，一定要多动手画图，这样才能理解的更充分。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        //前序遍历交换左右节点即可
        dfs(root);
        return root;
    }
    void dfs(TreeNode* node){
        if(node == nullptr) return;
        //交换节点
        TreeNode* temp = node-&gt;left;
        node-&gt;left = node-&gt;right;
        node-&gt;right = temp;
        //遍历左右子树
        dfs(node-&gt;left);
        dfs(node-&gt;right);
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>那么递归版写了，<strong>递归的迭代版</strong>怎么能拉下呢</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        //前序遍历的迭代法
        stack&lt;TreeNode*&gt; st;
        if(root != nullptr) st.push(root);
        while(!st.empty()){
            TreeNode* cur = st.top();
            if(cur != nullptr){
                st.pop();
                st.push(cur);
                st.push(nullptr);
                if(cur-&gt;right) st.push(cur-&gt;right);
                if(cur-&gt;left) st.push(cur-&gt;left);
            }
            else{
                st.pop();
                cur = st.top();
                st.pop();
                swap(cur-&gt;left, cur-&gt;right);
            }
        }
        return root;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>层序遍历</strong>当然也可以啦</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        queue&lt;TreeNode*&gt; q;
        if(root != nullptr) q.push(root);
        while(!q.empty()){
            TreeNode* cur = q.front();
            q.pop();
            swap(cur-&gt;left, cur-&gt;right);
            if(cur-&gt;left) q.push(cur-&gt;left);
            if(cur-&gt;right) q.push(cur-&gt;right);
        }
        return root;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题6：101-对称二叉树"><a href="#例题6：101-对称二叉树" class="headerlink" title="例题6：101. 对称二叉树"></a>例题6：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211001203837357.png" alt="image-20211001203837357" style="zoom:80%;">

<p>这题和上面那题可不一样啊，这题不是比较左右节点，而是左右子树，且是外侧和内侧的左右子树。</p>
<p>那么应该用那种遍历方式呢？我们观察，要比较外侧和内侧，那么左边就只能是左右中，右边就是右左中。其实这就是后序遍历，左右节点比较完再比较中间节点，即逻辑处理（因为只有知道子树是否对称才能知道父节点是否对称）。</p>
<p><strong>递归版：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == nullptr) return false;
        return compare(root-&gt;left, root-&gt;right);
    }
    bool compare(TreeNode* left, TreeNode* right){
        //结束条件
        if(left == nullptr &amp;&amp; right == nullptr){
            return true;
        }
        else if(left != nullptr &amp;&amp; right == nullptr){
            return false;
        }
        else if(left == nullptr &amp;&amp; right != nullptr){
            return false;
        }
        else if(left-&gt;val != right-&gt;val){
            return false;
        }
        //左右两节点存在且值相等，接下来比较两节点的外侧和内侧
        bool outside = compare(left-&gt;left, right-&gt;right);
        bool inside = compare(left-&gt;right, right-&gt;left);
        bool isSame = outside &amp;&amp; inside;
        return isSame;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>迭代版：</strong>这个不是层序遍历，就是把节点存入队列中进行访问</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        queue&lt;TreeNode*&gt; q;
        if(root != nullptr){
            q.push(root-&gt;left);
            q.push(root-&gt;right);
        }
        else return false;
        while(!q.empty()){
            TreeNode* cur1 = q.front(); q.pop();
            TreeNode* cur2 = q.front(); q.pop();
            if(cur1 == nullptr &amp;&amp; cur2 != nullptr) return false;
            else if(cur1 != nullptr &amp;&amp; cur2 == nullptr) return false;
            else if(cur1 != nullptr &amp;&amp; cur2 != nullptr){
                if(cur1-&gt;val != cur2-&gt;val) return false;
                else{
                    q.push(cur1-&gt;left);
                    q.push(cur2-&gt;right);
                    q.push(cur1-&gt;right);
                    q.push(cur2-&gt;left);
                }
            }
        }
        return true;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这一版是逻辑处理简化了的，更好看。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        queue&lt;TreeNode*&gt; q;
        if(root != nullptr){
            q.push(root-&gt;left);
            q.push(root-&gt;right);
        }
        while(!q.empty()){
            TreeNode* cur1 = q.front(); q.pop();
            TreeNode* cur2 = q.front(); q.pop();
            if(cur1 == nullptr &amp;&amp; cur2 == nullptr) continue;
            if(!cur1 || !cur2 || (cur1-&gt;val != cur2-&gt;val)) return false;
            if(cur1 == nullptr &amp;&amp; cur2 != nullptr) return false;
            q.push(cur1-&gt;left);
            q.push(cur2-&gt;right);
            q.push(cur1-&gt;right);
            q.push(cur2-&gt;left);
        }
        return true;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这题和 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一棵树的子树</a>、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree">100. 相同的树</a> 很相似，大家做完了可以做做这两题。</p>
<h4 id="例题7：104-二叉树的最大深度"><a href="#例题7：104-二叉树的最大深度" class="headerlink" title="例题7：104. 二叉树的最大深度"></a>例题7：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211002145736293.png" alt="image-20211002145736293" style="zoom:80%;">

<p>这题我知道可以用DFS，但是不会呀，难受，只能先用BFS搜索了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue&lt;TreeNode*&gt; q;
        if(root != nullptr) q.push(root);
        int cnt = 0;
        while(!q.empty()){
            int sz = q.size();
            for(int i = 0; i &lt; sz; i++){
                TreeNode* cur = q.front();
                q.pop();
                if(cur-&gt;left) q.push(cur-&gt;left);
                if(cur-&gt;right) q.push(cur-&gt;right);
            }
            cnt++;
        }
        return cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>学成归来，哈哈，下面就是DFS版了。<em><strong>需要用到递归返回值的都是后序遍历？！？</strong></em></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int maxDepth(TreeNode* root) {
        return dfs(root);
    }
    int dfs(TreeNode* node){
        if(node == nullptr) return 0;
        //先找左子树深度，再找右子树深度，最后取最大的那个加1，就是父节点的深度
        int depthLeft = dfs(node-&gt;left); //左
        int depthRight = dfs(node-&gt;right); //右
        int depth = max(depthLeft, depthRight) + 1; //中
        return depth;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题8：559-N-叉树的最大深度"><a href="#例题8：559-N-叉树的最大深度" class="headerlink" title="例题8：559. N 叉树的最大深度"></a>例题8：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211002151209814.png" alt="image-20211002151209814" style="zoom:80%;">

<p>和二叉树一个套路，不过就是子树变多了，也要用循环来进行遍历递归。这里我就只写递归了</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*
// Definition for a Node.
class Node {
public:
    int val;
    vector&lt;Node*&gt; children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector&lt;Node*&gt; _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int maxDepth(Node* root) {
        return dfs(root);
    }
    int dfs(Node* node){
        if(node == NULL) return 0;
        int depth_Max = 0;
        for(Node* cur : node-&gt;children){
            depth_Max = max(depth_Max, dfs(cur));
        }
        return depth_Max + 1;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题9：111-二叉树的最小深度"><a href="#例题9：111-二叉树的最小深度" class="headerlink" title="例题9：111. 二叉树的最小深度"></a>例题9：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211002151402239.png" alt="image-20211002151402239" style="zoom:80%;">

<p>这题和上面那题还是有点不太一样的，主要是处理中节点的时候不太一样。因为题目要求的是返回<strong>根节点</strong>到最近的<strong>叶子节点</strong>的深度，所以如果左子树为空而右子树不为空，那么返回右子树深度 + 1；如果右子树为空，左子树不为空，那么返回左子树深度 + 1；两者都不为空，返回最小的那个 + 1。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        return dfs(root);
    }
    int dfs(TreeNode* node){
        if(node == nullptr) return 0;
        int depth_left = dfs(node-&gt;left);
        int depth_right = dfs(node-&gt;right);
        if(!node-&gt;left &amp;&amp; node-&gt;right) return depth_right + 1;
        if(node-&gt;left &amp;&amp; !node-&gt;right) return depth_left + 1;
        return min(depth_left, depth_right) + 1;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面是迭代法，说实话我居然没写出来。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int minDepth(TreeNode* root) {
        int depth = 0;
        queue&lt;TreeNode*&gt; q;
        if(root != nullptr) q.push(root);
        while(!q.empty()){
            depth++;
            int sz = q.size();
            for(int i = 0; i &lt; sz; i++){
                TreeNode* cur = q.front();
                q.pop();
                if(cur-&gt;left) q.push(cur-&gt;left);
                if(cur-&gt;right) q.push(cur-&gt;right);
     //当左右子树都为空，说明已经到达了叶子节点，可以退出了（对呀，左右子树为空不就是也i直接点吗）
                if(!cur-&gt;left &amp;&amp; !cur-&gt;right) return depth;
            }
        }
        return depth;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题10：222-完全二叉树的节点个数"><a href="#例题10：222-完全二叉树的节点个数" class="headerlink" title="例题10：222. 完全二叉树的节点个数"></a>例题10：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211004184350156.png" alt="image-20211004184350156" style="zoom:80%;">

<p>这道题的普通解法和上面几题的求深度的题目很类似。我们递归求左右子树的节点，最后加起来再+ 1 最为中节点的节点数。同样因为用到了返回值，所以采用后序遍历。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        return dfs(root);
    }
    int dfs(TreeNode* node){
        if(node == nullptr) return 0;
        int leftNodes = dfs(node-&gt;left);
        int rightNodes = dfs(node-&gt;right);
        int cnt = leftNodes + rightNodes + 1;
        return cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>层序遍历</strong>也来一遍熟悉一下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int countNodes(TreeNode* root) {
        int cnt = 0;
        queue&lt;TreeNode*&gt; q;
        if(root != nullptr) q.push(root);
        
        while(!q.empty()){
            TreeNode* cur = q.front();
            q.pop();
            cnt++;
            if(cur-&gt;left){
                q.push(cur-&gt;left);
            }
            if(cur-&gt;right){
                q.push(cur-&gt;right);
            }
        }
        return cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面两种都没利用到完全二叉树的性质，完全二叉树是指 1 到 n - 1层为满二叉树，只有最后一层可能少几个节点，但是从左数是连续的，少的是最右边的几个节点。</p>
<p>所以我们可以利用公式来求满二叉树的节点数，不是满二叉树就用前面的方法来求。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int countNodes(TreeNode* root) {
        return dfs(root);
    }
    int dfs(TreeNode* node){
        //满二叉树是左右节点都存在或都不存在
        if(node == nullptr) return 0;
        TreeNode* left = node-&gt;left;
        TreeNode* right = node-&gt;right;
        //遍历最左边和最右边获取高度，高度一样则为满二叉树，否则按照正常相加
        int leftHeight = 0, rightHeight = 0;
        while(left){
            left = left-&gt;left;
            leftHeight++;
        }
        while(right){
            right = right-&gt;right;
            rightHeight++;
        }
        if(leftHeight == rightHeight){
            return (2 &lt;&lt; leftHeight) - 1;
        }
        return dfs(node-&gt;left) + dfs(node-&gt;right) + 1;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>时间复杂度为O(logN) * O(logN)</p>
<h4 id="例题11：110-平衡二叉树"><a href="#例题11：110-平衡二叉树" class="headerlink" title="例题11：110. 平衡二叉树"></a>例题11：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211004194824093.png" alt="image-20211004194824093" style="zoom:80%;">

<p>因为这题是求高度，所以是从下到上遍历——后序遍历；如果是求深度那么就是从上到下遍历——前序遍历。那可能有人就要问前面求二叉树的深度也没用前序遍历呀。那是因为代码的逻辑是求根的高度，所以还是使用的后序遍历。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(dfs(root) == -1) return false;
        return true;
    }
    int dfs(TreeNode* node){
        //后序遍历
        if(node == nullptr) return 0;
        //如果左子树不满足条件，则返回-1
        int leftHeight = dfs(node-&gt;left);
        if(leftHeight == -1) return -1;
        //右子树不满足条件返回-1
        int rightHeight = dfs(node-&gt;right);
        if(rightHeight == -1) return -1;
        //最后判断中间节点
        if(abs(leftHeight - rightHeight) &gt; 1) return -1;
        return max(leftHeight, rightHeight) + 1;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题12：257-二叉树的所有路径"><a href="#例题12：257-二叉树的所有路径" class="headerlink" title="例题12：257. 二叉树的所有路径"></a>例题12：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211006143506012.png" alt="image-20211006143506012" style="zoom:80%;">

<p>因为是要返回路径，所以是前序遍历。当然还涉及到回溯了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
        vector&lt;string&gt; res;
        dfs(root, "", res);
        return res;
    }
    void dfs(TreeNode* node, string path, vector&lt;string&gt;&amp; res){
        path += to_string(node-&gt;val);
        if(!node-&gt;left &amp;&amp; !node-&gt;right){
            res.push_back(path);
            return;
        }
        if(node-&gt;left){
            dfs(node-&gt;left, path + "-&gt;", res);
        }
        if(node-&gt;right){
            dfs(node-&gt;right, path + "-&gt;", res);
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还可以用BFS来写，不过我是看来题解才知道的，要用到两个队列，一个储存节点，一个存储路径。这样左右子树就不会共用一条路径。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
        vector&lt;string&gt; res;
        if(root == nullptr) return res;
        queue&lt;TreeNode*&gt; q_node;
        queue&lt;string&gt; q_path;
        q_node.push(root);
        q_path.push(to_string(root-&gt;val));
        while(!q_node.empty()){
            TreeNode* node = q_node.front(); q_node.pop();
            string path = q_path.front(); q_path.pop();
            if(!node-&gt;left &amp;&amp; !node-&gt;right){
                res.push_back(path);
            }
            else{
                if(node-&gt;left){
                    q_node.push(node-&gt;left);
                    q_path.push(path + "-&gt;" + to_string(node-&gt;left-&gt;val));
                }
                if(node-&gt;right){
                    q_node.push(node-&gt;right);
                    q_path.push(path + "-&gt;" + to_string(node-&gt;right-&gt;val));
                }
            }
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题13：404-左叶子之和"><a href="#例题13：404-左叶子之和" class="headerlink" title="例题13：404. 左叶子之和"></a>例题13：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211007151719453.png" alt="image-20211007151719453" style="zoom:80%;">

<p>这题可以用BFS，而且也比较容易，所以就不写了。直接写DFS吧。</p>
<p>这题还是得用后序遍历，因为<strong>需要函数的返回值</strong>，这里有个小细节——<strong>左叶子是左右节点都不存在的左节点</strong></p>
<p><strong>代码如下：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        return dfs(root);
    }
    int dfs(TreeNode* node){
        if(node == nullptr){
            return 0;
        }
        int sum1 = dfs(node-&gt;left);
        int sum2 = dfs(node-&gt;right);
        int sum = sum1 + sum2;
        if(node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right) sum += node-&gt;left-&gt;val;
        return sum;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题14：513-找树左下角的值"><a href="#例题14：513-找树左下角的值" class="headerlink" title="例题14：513. 找树左下角的值"></a>例题14：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211007153826126.png" alt="image-20211007153826126" style="zoom:80%;">

<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211007153839891.png" alt="image-20211007153839891" style="zoom:80%;">

<p>终于来了个medium难度的题了吗。用BFS写的话没有什么难度，但是DFS感觉比较难想。</p>
<p>先贴个BFS的吧：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue&lt;TreeNode*&gt; q;
        if(root != nullptr) q.push(root);
        int num;
        while(!q.empty()){
            int sz = q.size();
            num = q.front()-&gt;val;
            for(int i = 0; i &lt; sz; i++){
                TreeNode* cur = q.front();
                q.pop();
                if(cur-&gt;left) q.push(cur-&gt;left);
                if(cur-&gt;right) q.push(cur-&gt;right);
            }
        }
        return num;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>遍历整棵树不需要返回值，如果只遍历一条固定路径，则必须有返回值。这道题不需要返回值，我们记录最大的深度，然后下一层时就更新数值，这里使用前序遍历保证是最左边的数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int maxLen = INT_MIN;
    int maxLeftValue;
    int findBottomLeftValue(TreeNode* root) {
        //这题用递归的话，还是得找深度，返回深度最大的最左边节点就行了。前序遍历可以保证是最左边节点
        dfs(root, 0);
        return maxLeftValue;
    }
    void dfs(TreeNode* node, int depth){
        if(node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr){
            if(depth &gt; maxLen){
                maxLen = max(maxLen, depth);
                maxLeftValue = node-&gt;val;
            }
            return;
        }
        if(node-&gt;left) dfs(node-&gt;left, depth + 1);
        if(node-&gt;right) dfs(node-&gt;right, depth + 1);
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题15：106-从中序与后序遍历序列构造二叉树"><a href="#例题15：106-从中序与后序遍历序列构造二叉树" class="headerlink" title="例题15：106. 从中序与后序遍历序列构造二叉树"></a>例题15：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211013174719423.png" alt="image-20211013174719423" style="zoom:80%;">

<p>这是一道根据中序和后序构造二叉树的问题，构造二叉树都需要中序遍历。</p>
<p>对于此问题，我们可以每次使用后序数组的最后一个元素，它就是根节点。然后根据这个根节点把前序分成左右两个数组，这两个数组分别是左子树和右子树。所以因为左子树和右子树的大小已经确定，而后序遍历又是左右中的遍历方法，所以我们可以根据已得到的左右子树的大小分割后序数组。以此递归下去。</p>
<p><strong>来看⼀下⼀共分⼏步：</strong></p>
<ul>
<li><strong>第⼀步</strong>：如果数组⼤⼩为零的话，说明是空节点了。</li>
<li><strong>第⼆步</strong>：如果不为空，那么取后序数组最后⼀个元素作为节点元素。</li>
<li><strong>第三步</strong>：找到后序数组最后⼀个元素在中序数组的位置，作为切割点</li>
<li><strong>第四步</strong>：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，⼀定是先切中序数组）</li>
<li><strong>第五步</strong>：切割后序数组，切成后序左数组和后序右数组</li>
<li><strong>第六步</strong>：递归处理左区间和右区间</li>
</ul>
<p>代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
        return dfs(inorder, postorder);
    }
    //我们可以每次用后续遍历的最后一个节点（根节点）来分割中序数组。然后再利用中序数组来进行分割后序数组
    TreeNode* dfs(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder){
        //没有节点，已构造完，返回空
        if(postorder.size() == 0) return nullptr;
        //非空话，就构造这个根节点
        int rootValue = postorder[postorder.size() - 1];
        TreeNode* root = new TreeNode(rootValue);
        //postorder长度为1的话，就是叶子节点了
        if(postorder.size() == 1) return root;

        //找在中序数组中的分割点
        int delimiterIndex;
        for(delimiterIndex = 0; delimiterIndex &lt; inorder.size(); delimiterIndex++){
            if(inorder[delimiterIndex] == rootValue) break;
        }
        //分割中序数组，这里我们选择左闭右开
        //[0, delimiterIndex)
        vector&lt;int&gt; leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);
        //[delimiterIndex + 1, end) 
        vector&lt;int&gt; rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end());
        //分割后序数组，因为后序数组的左右子树的数组大小肯定和前序的左右子树大小相同，所以可以根据此来分割
        //不过我们得先把最后那个根节点给去掉
        postorder.resize(postorder.size() - 1);
        //[0, leftInorder.size())
        vector&lt;int&gt; leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        //[leftInorder.size(), end)
        vector&lt;int&gt; rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());

        // // ⼀下为⽇志
        // cout &lt;&lt; "----------" &lt;&lt; endl;
        // cout &lt;&lt; "leftInorder :";
        // for (int i : leftInorder) {
        //     cout &lt;&lt; i &lt;&lt; " ";
        // }
        // cout &lt;&lt; endl;
        // cout &lt;&lt; "rightInorder :";
        // for (int i : rightInorder) {
        //     cout &lt;&lt; i &lt;&lt; " ";
        // }
        // cout &lt;&lt; endl;
        // cout &lt;&lt; "leftPostorder :";
        // for (int i : leftPostorder) {
        //     cout &lt;&lt; i &lt;&lt; " ";
        // }
        // cout &lt;&lt; endl;
        // cout &lt;&lt; "rightPostorder :";
        // for (int i : rightPostorder) {
        //     cout &lt;&lt; i &lt;&lt; " ";
        // }
        //最后在递归左子树和右子树
        root-&gt;left = dfs(leftInorder, leftPostorder);
        root-&gt;right = dfs(rightInorder, rightPostorder);
        return root;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>提交返现效率还挺低的，我们还可以优化一下，至少不用重复定义数组。可以利用下标进行标记数组。感觉还挺麻烦，容易写错。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
        return dfs(inorder, postorder, 0, inorder.size(), 0, postorder.size());
    }
    //我们可以每次用后续遍历的最后一个节点（根节点）来分割中序数组。然后再利用中序数组来进行分割后序数组
    TreeNode* dfs(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int inorderBegin, int inorderEnd, int postorderBegin, int postorderEnd){
        //没有节点，已构造完，返回空
        if(postorderBegin == postorderEnd) return nullptr;
        //非空话，就构造这个根节点
        int rootValue = postorder[postorderEnd - 1];
        TreeNode* root = new TreeNode(rootValue);
        //postorder长度为1的话，就是叶子节点了
        if(postorderEnd == postorderBegin + 1) return root;

        //找在中序数组中的分割点
        int delimiterIndex;
        for(delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++){
            if(inorder[delimiterIndex] == rootValue) break;
        }
        
        //分割中序数组，这里我们选择左闭右开
        //[0, delimiterIndex)
        int leftInorderBegin = inorderBegin;
        int leftInorderEnd = inorderBegin + delimiterIndex;

        //[delimiterIndex + 1, end) 
        int rightInorderBegin = delimiterIndex + 1;
        int rightInorderEnd = inorderEnd;
        
        //分割后序数组，因为后序数组的左右子树的数组大小肯定和前序的左右子树大小相同，所以可以根据此来分割
        //不过我们得先把最后那个根节点给去掉
        //[0, leftInorder.size())
        int leftPostorderBegin = postorderBegin;
        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin;
        //[leftInorder.size(), end)
        int rightPostorderBegin = postorderBegin + delimiterIndex - inorderBegin;
        int rightPostorderEnd = postorderEnd - 1;

        //最后在递归左子树和右子树
        root-&gt;left = dfs(inorder, postorder, leftInorderBegin, leftInorderEnd, leftPostorderBegin, leftPostorderEnd);
        root-&gt;right = dfs(inorder, postorder, rightInorderBegin, rightInorderEnd, rightPostorderBegin, rightPostorderEnd);
        return root;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题16：105-从前序与中序遍历序列构造二叉树"><a href="#例题16：105-从前序与中序遍历序列构造二叉树" class="headerlink" title="例题16：105. 从前序与中序遍历序列构造二叉树"></a>例题16：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211014130301540.png" alt="image-20211014130301540" style="zoom:80%;">

<p>这题和上题思路差不多一样，不过就是把分割的点遍历一下，不过要注意中序遍历也得去掉那个根节点，好几次wrong都是那里的错。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        return dfs(preorder, inorder);
    }
    //与后序和中序构造二叉树的思路类似
    TreeNode* dfs(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder){
        if(preorder.size() == 0) return nullptr;
        int rootValue = preorder[0];
        TreeNode* root = new TreeNode(rootValue);
        //节点数为一，则为叶子节点
        if(preorder.size() == 1) return root;

        //找中序遍历的分割点
        int delimiterIndex;
        for(delimiterIndex = 0; delimiterIndex &lt; inorder.size(); delimiterIndex++){
            if(inorder[delimiterIndex] == rootValue) break;
        }

        //分割中序与前序
        vector&lt;int&gt; leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);
        vector&lt;int&gt; rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end());

        vector&lt;int&gt; leftPreorder(preorder.begin() + 1, preorder.begin() + leftInorder.size() + 1);
        vector&lt;int&gt; rightPreoreder(preorder.begin() + leftInorder.size() + 1, preorder.end());

        //进行左右子树的递归分割
        root-&gt;left = dfs(leftPreorder, leftInorder);
        root-&gt;right = dfs(rightPreoreder, rightInorder);
        return root;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题17：654-最大二叉树"><a href="#例题17：654-最大二叉树" class="headerlink" title="例题17：654. 最大二叉树"></a>例题17：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211015142157452.png" alt="image-20211015142157452" style="zoom:80%;">

<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211015142226534.png" alt="image-20211015142226534" style="zoom:80%;">

<p>这题和上面两题前中、后中构造二叉树的思路类似，所以直接秒了。这个也是二叉树的前序遍历思路吧。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {
        return dfs(nums, 0, nums.size());
    }
    TreeNode* dfs(vector&lt;int&gt;&amp; nums, int begin, int end){
        if(begin == end) return nullptr;
        int rootIndex = begin;
        for(int i = begin; i &lt; end; i++){
            if(nums[i] &gt; nums[rootIndex]){
                rootIndex = i;
            }
        }
        //构造根节点
        TreeNode* root = new TreeNode(nums[rootIndex]);

        //找左右子树的数组
        int leftBegin = begin;
        int leftEnd = rootIndex;

        int rightBegin = rootIndex + 1;
        int rightEnd = end;

        //递归左右子树
        root-&gt;left = dfs(nums, leftBegin, leftEnd);
        root-&gt;right = dfs(nums, rightBegin, rightEnd);
        return root;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题18：230-二叉搜索树中第K小的元素"><a href="#例题18：230-二叉搜索树中第K小的元素" class="headerlink" title="例题18：230. 二叉搜索树中第K小的元素"></a>例题18：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211017140557883.png" alt="image-20211017140557883" style="zoom:80%;">

<p>因为是二叉搜索树，所以只需要用前序遍历找到第k个元素就行。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int value = -1;
    int cnt = 0;
    int kthSmallest(TreeNode* root, int k) {
        dfs(root, k);
        return value;
    }
    void dfs(TreeNode* node, int k){
        if(node == 0 || value != -1) return;
        dfs(node-&gt;left, k);
        cnt += 1;
        if(cnt == k) value = node-&gt;val;
        dfs(node-&gt;right, k);
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>如果你需要频繁地查找第 k小的值，你将如何优化算法？</p>
</blockquote>
<p>这里先给出官方的题解思路吧，后续再看/(ㄒoㄒ)/~~，现在太困了。</p>
<p><strong>官方题解：</strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/er-cha-sou-suo-shu-zhong-di-kxiao-de-yua-8o07/">二叉搜索树中第K小的元素 - 二叉搜索树中第K小的元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h4 id="例题19：617-合并二叉树"><a href="#例题19：617-合并二叉树" class="headerlink" title="例题19：617. 合并二叉树"></a>例题19：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><img src="images/数据结构和算法/image-20211029194442286.png" alt="image-20211029194442286" style="zoom:80%;">

<p>因为题目提示了合并从根节点开始，所以直接一个前序遍历就ok了</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        //从根节点开始合并，那不就是前序遍历吗
        return dfs(root1, root2);
    }
    TreeNode* dfs(TreeNode* node1, TreeNode* node2){
        if(node1 == nullptr &amp;&amp; node2 == nullptr) return nullptr;
        int rootValue = 0;
        if(node1 != nullptr) rootValue += node1-&gt;val;
        if(node2 != nullptr) rootValue += node2-&gt;val;
        TreeNode* root = new TreeNode(rootValue);

        //左右递归子树
        if(node1 == nullptr){
            root-&gt;left = dfs(nullptr, node2-&gt;left);
            root-&gt;right = dfs(nullptr, node2-&gt;right);
        }
        else if(node2 == nullptr){
            root-&gt;left = dfs(node1-&gt;left, nullptr);
            root-&gt;right = dfs(node1-&gt;right, nullptr);
        }
        else{
            root-&gt;left = dfs(node1-&gt;left, node2-&gt;left);
            root-&gt;right = dfs(node1-&gt;right, node2-&gt;right);
        }
        return root;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还可以再简洁一点，遇到一个节点为空，返回另一个节点就行了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        //从根节点开始合并，那不就是前序遍历吗
        return dfs(root1, root2);
    }
    TreeNode* dfs(TreeNode* node1, TreeNode* node2){
        if(node1 == nullptr) return node2;
        if(node2 == nullptr) return node1;
        int rootValue = 0;
        if(node1 != nullptr) rootValue += node1-&gt;val;
        if(node2 != nullptr) rootValue += node2-&gt;val;
        TreeNode* root = new TreeNode(rootValue);

        //左右递归子树
        root-&gt;left = dfs(node1-&gt;left, node2-&gt;left);
        root-&gt;right = dfs(node1-&gt;right, node2-&gt;right);
        return root;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题20：236-二叉树的最近公共祖先"><a href="#例题20：236-二叉树的最近公共祖先" class="headerlink" title="例题20：236. 二叉树的最近公共祖先"></a>例题20：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><img src="images/数据结构和算法/image-20211105215028614.png" alt="image-20211105215028614" style="zoom:80%;">

<p>这题明显是后序遍历的过程，不过我感觉一直对有返回值类型的DFS不太熟悉啊。而且隔了几天再做一遍发现居然不回了，惭愧惭愧，还是写一下大概思路吧，加强理解。</p>
<p>很明显要从叶子节点找起，所以可以考虑后序遍历。我们如果找到一个节点，其左子树有节点p，右子树有节点q或者反过来，那么该节点就是最近的公共祖先节点。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return dfs(root, p, q);
    }
    TreeNode* dfs(TreeNode* node, TreeNode* p, TreeNode* q){
        if(node == p || node == q || node == NULL) return node;
        TreeNode* left = dfs(node-&gt;left, p, q);
        TreeNode* right = dfs(node-&gt;right, p, q);
        if(left != NULL &amp;&amp; right != NULL){
            return node;
        }
        else if(right != NULL){
            return right;
        }
        return left;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题21：563-二叉树的坡度"><a href="#例题21：563-二叉树的坡度" class="headerlink" title="例题21：563. 二叉树的坡度"></a>例题21：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-tilt/">563. 二叉树的坡度</a></h4><img src="images/数据结构和算法/image-20211118122108936.png" alt="image-20211118122108936" style="zoom:80%;">

<p>这题是简单题，但好久没做树的题目，居然没想出来，罪过罪过啊。</p>
<p>这题思路如下：</p>
<p>我们求每个节点的左右子树值的和，然后相减取绝对值就行。主要忘了怎么求和了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = 0;
    int findTilt(TreeNode* root) {
        dfs(root);
        return ans;
    }
    int dfs(TreeNode* node){
        if(node == nullptr) return 0;
        int left = dfs(node-&gt;left);
        int right = dfs(node-&gt;right);
        ans += abs(left - right);
        return node-&gt;val + left + right;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="前缀树（字典树-单词树）"><a href="#前缀树（字典树-单词树）" class="headerlink" title="前缀树（字典树/单词树）"></a>前缀树（字典树/单词树）</h3><h4 id="例题1：212-单词搜索-II"><a href="#例题1：212-单词搜索-II" class="headerlink" title="例题1：212. 单词搜索 II"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210916132627367.png" alt="image-20210916132627367" style="zoom:80%;">

<p>典型的字典树问题，我们可以把words中的单词加入到字典树中，然后遍历boards中的每一个节点，进行递归查找。</p>
<p>首先介绍一下字典树吧：</p>
<blockquote>
<p>【字典树】(Trie Tree) 是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串）。<br>它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。<br>                                                    ——百度 · 百科<br>————————————————<br>版权声明：本文为CSDN博主「samarua」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46202073/article/details/107253959">https://blog.csdn.net/m0_46202073/article/details/107253959</a></p>
</blockquote>
<p>就举这题的第一个测试用例的例子吧<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210916133942155.png" alt="image-20210916133942155" style="zoom:80%;"></p>
<p>目前知道的字典树的含义及作用，现在我们来创建字典树</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TrieNode {
    string word;
    unordered_map&lt;int, TrieNode*&gt; children;
    TrieNode(){
        this-&gt;word = "";
    }
}
void insertTrie(TrieNode* root, string word){
    TrieNode* node = root;
    for(char c : word){
        //没有字符c开头的子节点，则创建它
        if(!node-&gt;children.count(c)){
            node-&gt;children[c] = new TrieNode();
        }
        //继续这个单词后面的字符
        node = node-&gt;children[c];
    }
    node-&gt;word = word;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还有一种创建方法，就是用下标表示字母，这个方法就在我上面发的那个链接那看吧</p>
<p>接下来重点就是dfs了，我们每次向四个方向搜索，搜索的节点对应的word长度大于0，说明该路径是一个完整的单词，则加入到set中，set的目的是为了去重，因为不同路径可能有相同的单词。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TrieNode{
    string word;
    unordered_map&lt;char, TrieNode*&gt; children;
    TrieNode(){
        this-&gt;word = "";
    } 
};
void insertTrie(TrieNode* root, const string&amp; word){
    TrieNode* node = root;
    for(char c : word){
        //即node节点下没有这个字符，则创建一个
        if(!node-&gt;children.count(c)){
            node-&gt;children[c] = new TrieNode();
        }
        node = node-&gt;children[c];
    }
    node-&gt;word = word;
}
class Solution {
public:
    int dict[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, TrieNode* root, set&lt;string&gt;&amp; res){
        char c = board[x][y];
        //没有以c为前缀的单词，剪枝
        if(!root-&gt;children.count(c)){
            return false;
        }
        root = root-&gt;children[c];
        if(root-&gt;word.size() &gt; 0){
            res.insert(root-&gt;word);
            root-&gt;word = "";
        }
        board[x][y] = '#';
        for(int i = 0; i &lt; 4; i++){
            int nx = x + dict[i][0];
            int ny = y + dict[i][1];
            if(nx &gt;= 0 &amp;&amp; nx &lt; board.size() &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; board[0].size()){
                if(board[nx][ny] != '#'){
                    dfs(board, nx, ny, root, res);
                }
            }
        }
        board[x][y] = c;
        return true;
    }
    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) {
        set&lt;string&gt; res;
        vector&lt;string&gt; ans;
        TrieNode* root = new TrieNode();
        for(string s : words){
            insertTrie(root, s);
        }
        int n = board.size();
        int m = board[0].size();
        for(int i = 0; i &lt; n; i++){
            for(int j = 0; j &lt; m; j++){
                dfs(board, i, j, root, res);
            }
        }
        for(auto&amp; s : res){
            ans.push_back(s);
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="例题2：211-添加与搜索单词-数据结构设计"><a href="#例题2：211-添加与搜索单词-数据结构设计" class="headerlink" title="例题2：211. 添加与搜索单词 - 数据结构设计"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211019132926881.png" alt="image-20211019132926881" style="zoom:80%;">

<p>这题可以使用哈希加集合来解决，逻辑不难，就是实现哈希和集合不太熟悉，调试了好长时间。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class WordDictionary {
public:
    unordered_map&lt;int, set&lt;string&gt;&gt; words;
    WordDictionary() {

    }
    
    void addWord(string word) {
        int n = word.size();
        words[n].insert(word);
    }
    
    bool search(string word) {
        int n = word.size();
        if(words.count(n) == 0) return false;
        bool flag = true;
        for(auto iter = words[n].begin(); iter != words[n].end(); iter++){
            string s = *iter;
            //cout&lt;&lt;s&lt;&lt;" "&lt;&lt;word&lt;&lt;endl;
            int i;
            for(i = 0; i &lt; s.size(); i++){
                if(word[i] == '.') continue;
                else if(word[i] != s[i]){
                    flag = false;
                    break;
                }
            }
            if(i == s.size()){
                flag = true;
                break;
            }
        }
        return flag;
    }
};

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary* obj = new WordDictionary();
 * obj-&gt;addWord(word);
 * bool param_2 = obj-&gt;search(word);
 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>看到这道题要匹配字符串，我就想到了前缀树（又称字典树）。</p>
<p>不过这里还有 ‘ . ‘，所以遇到了点号就要遍历后续整棵树进行查找，我们可以借助dfs来遍历。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TireNode{
    string word;
    unordered_map&lt;char, TireNode*&gt; children;
    TireNode(){
        this-&gt;word = "";
    }
};
void insertTrie(TireNode* root, const string&amp; word){
    TireNode* node = root;
    for(char c : word){
        if(!node-&gt;children[c]){
            node-&gt;children[c] = new TireNode();
        }
        node = node-&gt;children[c];
    }
    node-&gt;word = word;
}
class WordDictionary {
public:
    TireNode* root;
    WordDictionary() {
        root = new TireNode();
    }
    
    void addWord(string word) {
        insertTrie(root, word);
    }
    
    bool search(string word) {
        return dfs(word, 0, root);
    }
    bool dfs(const string&amp; word, int index, TireNode* node){
        if(index == word.size()) return node-&gt;word != "";
        char c = word[index];
        if('a' &lt;= c &amp;&amp; c &lt;= 'z'){
            TireNode* child = node-&gt;children[c];
            if(child != NULL &amp;&amp; dfs(word, index + 1, child)) return true;
        }
        else{
            for(char i = 'a'; i &lt;= 'z'; i++){
                TireNode* child = node-&gt;children[i];
                if(child != NULL &amp;&amp; dfs(word, index + 1, child)) return true;
            }
        }
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题3：700-二叉搜索树中的搜索"><a href="#例题3：700-二叉搜索树中的搜索" class="headerlink" title="例题3：700. 二叉搜索树中的搜索"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211022192746086.png" alt="image-20211022192746086" style="zoom:80%;">

<p>搜索树（前缀树、字典树），这题就是考察搜索树的搜索（哈哈哈，哪里有点怪）</p>
<p><strong>迭代版：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        TreeNode* node = root;
        while(node != nullptr){
            if(node-&gt;val &gt; val){
                node = node-&gt;left;
            }
            else if(node-&gt;val &lt; val){
                node = node-&gt;right;
            }
            else return node;
        }
        return nullptr;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>DFS版：</strong></p>
<p>对于有返回值的DFS我还是不太熟悉怎么操作，还是要练啊。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        return dfs(root, val);
    }
    TreeNode* dfs(TreeNode* node, int val){
        //前序遍历就行了吧
        if(node == nullptr || node-&gt;val == val) return node;
        if(node-&gt;val &gt; val) return dfs(node-&gt;left, val);
        if(node-&gt;val &lt; val) return dfs(node-&gt;right, val);
        return nullptr;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题4：98-验证二叉搜索树"><a href="#例题4：98-验证二叉搜索树" class="headerlink" title="例题4：98. 验证二叉搜索树"></a>例题4：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211022203317030.png" alt="image-20211022203317030" style="zoom:80%;">

<p>要充分利用搜索树的特性，对搜索树使用中序遍历得到的序列是一个严格递增的序列，所以我们可以直接遍历得到这个序列，然后看是否是递增的就行。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; res;
    bool isValidBST(TreeNode* root) {
        res.clear();
        dfs(root);
        for(int i = 0; i &lt; res.size() - 1; i++){
            if(res[i] &gt;= res[i + 1]) return false;
        }
        return true;
    }
    void dfs(TreeNode* node){
        if(node == nullptr) return;
        //中序遍历下搜索树的序列是一个递增的序列

        if(node-&gt;left) dfs(node-&gt;left);
        res.push_back(node-&gt;val);
        if(node-&gt;right) dfs(node-&gt;right);
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>DFS版：我们可以在中序遍历的时候比较，只需要额外记录前一个值，然后与现在的进行比较。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    long long maxValue = LONG_MIN;
    bool isValidBST(TreeNode* root) {
        if(root == nullptr) return true;
        return dfs(root);
    }
    bool dfs(TreeNode* node){
        if(node == nullptr) return true;

        bool left = dfs(node-&gt;left);
        if(maxValue &gt;= node-&gt;val) return false;
        maxValue = node-&gt;val;
        bool right = dfs(node-&gt;right);
        return left &amp;&amp; right;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里是因为 int 类型，所以我们可以使用long类型的最小值，但是当数据为long时就不行了，所以我们可以换一下，记录前一个节点。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    TreeNode* pre = nullptr;
    bool isValidBST(TreeNode* root) {
        if(root == nullptr) return true;
        return dfs(root);
    }
    bool dfs(TreeNode* node){
        if(node == nullptr) return true;

        bool left = dfs(node-&gt;left);
        if(pre != nullptr &amp;&amp;  pre-&gt;val &gt;= node-&gt;val) return false;
        pre = node;
        bool right = dfs(node-&gt;right);
        return left &amp;&amp; right;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题5：501-二叉搜索树中的众数"><a href="#例题5：501-二叉搜索树中的众数" class="headerlink" title="例题5：501. 二叉搜索树中的众数"></a>例题5：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h4><img src="images/数据结构和算法/image-20211105210439028.png" alt="image-20211105210439028" style="zoom:80%;">

<p>这题的老办法是用哈希表记录每个元素出现的位置，最后排个序就行了。但是这可是二叉搜索树啊，中序遍历是有序的，所以我们可以设置一个前置节点记录前一个元素，然后与当前元素比较;相等，则count + 1，否则count = 1。最后还要设置countMax用来记录目前出现次数最多的值，然后拿count与countMax进行比较，相等则加入元素。大于countMax则清空数组，重新加入元素。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int count = 1;
    int countMax = 0;
    TreeNode* pre = nullptr;
    vector&lt;int&gt; ans;
    vector&lt;int&gt; findMode(TreeNode* root) {
        ans.clear();
        dfs(root);
        return ans;
    }
    void dfs(TreeNode* node){
        if(node == nullptr) return;

        dfs(node-&gt;left);
        if(pre == nullptr) count = 1;
        else if(pre-&gt;val == node-&gt;val) count++;
        else count = 1;
        pre = node;
        if(count == countMax){
            ans.push_back(pre-&gt;val);
        }
        else if(count &gt; countMax){
            countMax = count;
            ans.clear();
            ans.push_back(pre-&gt;val);
        }
        dfs(node-&gt;right);
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题6：235-二叉搜索树的最近公共祖先"><a href="#例题6：235-二叉搜索树的最近公共祖先" class="headerlink" title="例题6：235. 二叉搜索树的最近公共祖先"></a>例题6：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><img src="images/数据结构和算法/image-20211112193003739.png" alt="image-20211112193003739" style="zoom:80%;">

<p>这题和二叉树中的第20题很类似，不过20题是比较一般的做法，这题是搜索树，所以肯定更方便。确实如此，我们只需从上往下遍历，找到在p 、q之间的点返回就行了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //好吧，层序遍历就行了
        queue&lt;TreeNode*&gt; que;
        que.push(root);
        TreeNode* cur = NULL;
        int x = min(p-&gt;val, q-&gt;val);
        int y = max(p-&gt;val, q-&gt;val);
        while(!que.empty()){
            cur = que.front();
            que.pop();
            if(x &lt;= cur-&gt;val &amp;&amp; cur-&gt;val &lt;= y){
                break;
            }
            if(cur-&gt;left != NULL){
                que.push(cur-&gt;left);
            }
            if(cur-&gt;right != NULL){
                que.push(cur-&gt;right);
            }
        }
        return cur;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还是写了一下递归的写法，我们第20题一样，不过这题我们是遍历一条边就行，找到了就返回。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //同样也可以前序遍历，这里就dfs吧
        return dfs(root, p, q);
    }
    TreeNode* dfs(TreeNode* node, TreeNode* p, TreeNode* q){
        if(node == NULL) return node;
        
        if(node-&gt;val &gt; p-&gt;val &amp;&amp; node-&gt;val &gt; q-&gt;val){
            TreeNode* left = dfs(node-&gt;left, p, q);
            if(left != NULL){
                return left;
            }
        }
        else if(node-&gt;val &lt; p-&gt;val &amp;&amp; node-&gt;val &lt; q-&gt;val){
            TreeNode* right = dfs(node-&gt;right, p, q);
            if(right != NULL){
                return right;
            }
        }
        return node;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题7：701-二叉搜索树中的插入操作"><a href="#例题7：701-二叉搜索树中的插入操作" class="headerlink" title="例题7：701. 二叉搜索树中的插入操作"></a>例题7：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4><img src="images/数据结构和算法/image-20211112195931034.png" alt="image-20211112195931034" style="zoom:80%;">

<p>这题其实还不算难，因为没有刁难我们让我们返回所有结果🤣😂，所以我们可以就不在头节点插入，一直找到叶子节点的位置插入。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == nullptr) return new TreeNode(val);
        TreeNode* node= root;
        while(node != nullptr){
            if(node-&gt;val &gt; val){
                if(node-&gt;left){
                    node = node-&gt;left;
                }
                else{
                    node-&gt;left = new TreeNode(val);
                    break;
                }
            }
            else{
                if(node-&gt;right){
                    node = node-&gt;right;
                }
                else{
                    node-&gt;right = new TreeNode(val);
                    break;
                }
            }
        }
        return root;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还可以重新构造一个二叉搜索树。不需要遍历整棵树，二叉搜索树可以根据值的大小来决定遍历的方向。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    TreeNode* pre = nullptr;
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == nullptr) return new TreeNode(val);
        dfs(root, val);
        return root;
    }
    TreeNode* dfs(TreeNode* node, int val){
        if(node == nullptr){
            return new TreeNode(val);
        }
        TreeNode* root = node;
        if(root-&gt;val &gt; val){
            root-&gt;left = dfs(node-&gt;left, val);
        }
        if(root-&gt;val &lt; val){
            root-&gt;right = dfs(node-&gt;right, val);
        }
        return root;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里也可以不用重新构造一棵二叉树，可以设置一个父节点，然就插入即可。可以看出这里不要返回值的做法麻烦一些。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    TreeNode* parent;
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == nullptr) return new TreeNode(val);
        parent = new TreeNode(0);
        dfs(root, val);
        return root;
    }
    void dfs(TreeNode* node, int val){
        if(node == nullptr){
            if(parent-&gt;val &gt; val){
                parent-&gt;left = new TreeNode(val);
            }
            else{
                parent-&gt;right = new TreeNode(val);
            }
            return;
        }
        parent = node;
        if(node-&gt;val &lt; val) dfs(node-&gt;right, val);
        if(node-&gt;val &gt; val) dfs(node-&gt;left, val);
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例题8：450-删除二叉搜索树中的节点"><a href="#例题8：450-删除二叉搜索树中的节点" class="headerlink" title="例题8：450. 删除二叉搜索树中的节点"></a>例题8：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4><img src="images/数据结构和算法/image-20211126214307929.png" alt="image-20211126214307929" style="zoom:80%;">

<p>这道题我自己写了一个，但是有点问题，找对于右节点找不到父节点。所以我就看了看carl大佬的解题思路，甚是不错。</p>
<p>删除该节点分5种情况：</p>
<ol>
<li><strong>没有找到，返回空</strong></li>
<li><strong>左右节点都为空，直接返回空指针</strong></li>
<li><strong>左空右不空，直接返回右节点</strong></li>
<li><strong>右空左不空，直接返回左节点</strong></li>
<li><strong>左右都不空，这时候我们可以把左节点放到右节点的左叶节点的左节点上，然后删除父节点，返回右节点</strong></li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        return dfs(root, key);
    }
    TreeNode* dfs(TreeNode* node, int key){
        if(node == nullptr) return node;
        
        if(node-&gt;val &gt; key){
            node-&gt;left = dfs(node-&gt;left, key);
        }
        else if(node-&gt;val &lt; key){
            node-&gt;right = dfs(node-&gt;right, key);
        }
        else{
            if(node-&gt;left == nullptr){
                return node-&gt;right;
            }
            if(node-&gt;right == nullptr){
                return node-&gt;left;
            }
            TreeNode* cur = node-&gt;right;
            while(cur-&gt;left != nullptr){
                cur = cur-&gt;left;
            }
            //这里可能不太好理解。我们找到node的后继节点，然后赋值后继续递归来删除后继节点
            node-&gt;val = cur-&gt;val;
            node-&gt;right = dfs(node-&gt;right, node-&gt;val);
        }
        return node;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>官方题解是根据前继节点和后继节点来进行解题的，放个链接吧。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/shan-chu-er-cha-sou-suo-shu-zhong-de-jie-dian-by-l/">删除二叉搜索树中的节点 - 删除二叉搜索树中的节点 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int successor(TreeNode* root, int key){
        TreeNode* cur = root-&gt;right;
        while(cur-&gt;left != nullptr){
            cur = cur-&gt;left;
        }
        return cur-&gt;val;
    }
    int predecessor(TreeNode* root, int key){
        TreeNode* cur = root-&gt;left;
        while(cur-&gt;right != nullptr){
            cur = cur-&gt;right;
        }
        return cur-&gt;val;
    }
    TreeNode* deleteNode(TreeNode* root, int key) {
        /*
            要删除的节点分为3种情况：
            1、删除节点为叶子节点，直接删除即可
            2、删除节点不是叶子节点，且有右节点
            3、删除节点不是叶子节点，但是有右节点无左节点
            （这里2、3两种情况换一下也行，但是是左右节点换一下，不是整个换一下）
        */
        if(root == nullptr) return nullptr;

        if(root-&gt;val &gt; key){
            root-&gt;left = deleteNode(root-&gt;left, key);
        }
        else if(root-&gt;val &lt; key){
            root-&gt;right = deleteNode(root-&gt;right, key);
        }
        else{
            if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) root = nullptr;
            else if(root-&gt;right != nullptr){
                root-&gt;val = successor(root, key);
                root-&gt;right = deleteNode(root-&gt;right, root-&gt;val);
            }
            else{
                root-&gt;val = predecessor(root, key);
                root-&gt;left = deleteNode(root-&gt;left, root-&gt;val);
            }
        }
        return root;
    }


};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当然，这个官方的版本感觉和carl的另一个版本很像，我就直接贴了</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
 TreeNode* deleteNode(TreeNode* root, int key) {
    if (root == nullptr) return root; // 第⼀种情况：没找到删除的节点，遍历到空节点直接返回了
    if (root-&gt;val == key) {
        // 第⼆种情况：左右孩⼦都为空（叶⼦节点），直接删除节点， 返回NULL为根节点

        // 第三种情况：其左孩⼦为空，右孩⼦不为空，删除节点，右孩⼦补位 ，返回右孩⼦为根节点
        if (root-&gt;left == nullptr) return root-&gt;right;

        // 第四种情况：其右孩⼦为空，左孩⼦不为空，删除节点，左孩⼦补位，返回左孩⼦为根节点
        else if (root-&gt;right == nullptr) return root-&gt;left;

        // 第五种情况：左右节点不为空，则将删除节点的左⼦树放到删除节点的右⼦树的最左面节点的左孩⼦的位置
        // 并返回删除节点右孩⼦为新的根节点。
        else {
            TreeNode* cur = root-&gt;right; // 找右⼦树最左⾯的节点
            while(cur-&gt;left != nullptr) {
                cur = cur-&gt;left;
            }
            cur-&gt;left = root-&gt;left; // 把要删除的节点（root）左⼦树放在cur的左孩⼦的位置
            TreeNode* tmp = root; // 把root节点保存⼀下，下⾯来删除
            root = root-&gt;right; // 返回旧root的右孩⼦作为新root
            delete tmp; // 释放节点内存（这⾥不写也可以，但C++最好⼿动释放⼀下吧）
            return root;
        }
    }
    if (root-&gt;val &gt; key) root-&gt;left = deleteNode(root-&gt;left, key);
    if (root-&gt;val &lt; key) root-&gt;right = deleteNode(root-&gt;right, key);
    return root;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>先说下什么是最小生成树吧。<strong>树与图的区别在于图是有环的，而树没有环</strong>，那么生成树就图图中所有节点都联通的树，注意是所有节点。所以显然最小生成树就是所有可能的生成树中权重最小的那棵生成树。</p>
<img src="images/数据结构和算法/微信图片_20211104191632.png" style="zoom:80%;">

<p>这里就是右边的权重比左边小。</p>
<blockquote>
<p>PS：一般来说，我们都是在<strong>无向加权图</strong>中计算最小生成树的，所以使用最小生成树算法的现实场景中，图的边权重一般代表成本、距离这样的标量。</p>
</blockquote>
<p>生成树是所有节点的无环联通子图，那么涉及到联通首选想到的是<strong>并查集算法</strong>。</p>
<p>因为要求最小生成树，所以我们可以先把这些边的权重按递增的顺序排序。然后每次连接两个点，我们要判断这两个点是否在同一个联通分量里，如果在的话就会产生环，不符合要求。</p>
<h4 id="例题1：1584-连接所有点的最小费用"><a href="#例题1：1584-连接所有点的最小费用" class="headerlink" title="例题1：1584. 连接所有点的最小费用"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a></h4><img src="images/数据结构和算法/image-20211104193102692.png" alt="image-20211104193102692" style="zoom:80%;">

<p>这题就是典型的最小生成树模板题，只不过要自己处理一下边，结构体的用法都忘了，罪过罪过。顺便熟悉了一下sort的排序问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class UnionFind {
private:
    vector&lt;int&gt; parent;
    vector&lt;int&gt; size;
    int count;
public:
    UnionFind(int n){
        parent.resize(n);
        size.resize(n);
        count = n;
        for(int i = 0; i &lt; n; i++){
            parent[i] = i;
            size[i] = 1;
        }
    }
    int Find(int x){
        while(x != parent[x]){
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
    void Union(int x, int y){
        int root_x = Find(x);
        int root_y = Find(y);
        if(root_x == root_y) return;
        if(size[root_x] &gt; size[root_y]){
            parent[root_y] = root_x;
            size[root_x] += size[root_y];
        }
        else{
            parent[root_x] = root_y;
            size[root_y] += root_x;
        }
    }
    bool isConnected(int x, int y){
        int root_x = Find(x);
        int root_y = Find(y);
        return root_x == root_y;
    }
};
struct Edge{
    int power, x, y;
    Edge(int power, int x, int y) : power(power), x(x), y(y){}
};
class Solution {
public:
    //最小生成树啊
    int minCostConnectPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) {
        int n = points.size();
        UnionFind uf(n);
        vector&lt;Edge&gt; edges;
        for(int i = 0; i &lt; n - 1; i++){
            for(int j = i + 1; j &lt; n; j++){
                int xi = points[i][0], yi = points[i][1];
                int xj = points[j][0], yj = points[j][1];
                edges.push_back({abs(xi - xj) + abs(yi - yj), i, j});
            }
        }
        sort(edges.begin(), edges.end(), [](Edge a, Edge b) -&gt; int{return a.power &lt; b.power;});
        int ans = 0;
        for(auto&amp; [power, x, y] : edges){
            if(!uf.isConnected(x, y)){
                ans += power;
            }
            uf.Union(x, y);
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h3><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="例题1：496-下一个更大元素-I"><a href="#例题1：496-下一个更大元素-I" class="headerlink" title="例题1：496. 下一个更大元素 I"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h3><img src="images/数据结构和算法/image-20211026145502758.png" alt="image-20211026145502758" style="zoom:80%;">

<p>这题如果就是普通的遍历的话，很简单，但是题目要求的是O(m + n)的时间复杂度，所以得好好动动脑袋了。其实这题使用单调栈的思想很不错。</p>
<p>我们考虑[2, 1, 2, 4, 3]，找到每个元素的下一个大于它的数，没有则为-1。我们可以把这几个数抽象成几个身高不同的人排队。</p>
<p><img src="images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211026150159526.png" alt="image-20211026150159526"></p>
<p>其结果如下图所示，那么代码怎么写呢，看下面吧。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; ans(n);
        stack&lt;int&gt; st;
        for(int i = n - 1; i &gt;= 0; i--){
            //如果栈中有比nums[i]小的，拿出来，保持栈的单调
            while(!st.empty() &amp;&amp; nums[i] &gt;= q.top()){
                q.pop();
            }
            ans[i] = q.empty() ? -1 : q.top();
            q.push(nums[i]);
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>那么看懂的上面的之后，这题就是上面的一个变形罢了。利用哈希表存储这些数据，然后遍历nums1进行查找就完事了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int n = nums2.size();
        unordered_map&lt;int, int&gt; ans;
        stack&lt;int&gt; st;
        for(int i = n - 1; i &gt;= 0; i--){
            while(!st.empty() &amp;&amp; nums2[i] &gt;= st.top()){
                st.pop();
            }
            ans[nums2[i]] = st.empty() ? -1 : st.top();
            st.push(nums2[i]);
        }
        vector&lt;int&gt; res(nums1.size());
        for(int i = 0; i &lt; nums1.size(); i++){
            res[i] = ans[nums1[i]];
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>现在，你已经掌握了单调栈的使用技巧，来一个简单的变形来加深一下理解。</strong></p>
<p>给你一个数组 T = [73, 74, 75, 71, 69, 72, 76, 73]，这个数组存放的是近几天的天气气温。你返回一个数组，计算：对于每一天，你还要<strong>至少等多少天</strong>才能等到一个更暖和的气温；如果等不到那一天，填 0 。</p>
<p>举例：给你 T = [73, 74, 75, 71, 69, 72, 76, 73]，你返回 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>解释：第一天 73 华氏度，第二天 74 华氏度，比 73 大，所以对于第一天，只要等一天就能等到一个更暖和的气温。后面的同理。</p>
<p>你已经对 Next Greater Number 类型问题有些敏感了，这个问题本质上也是找 Next Greater Number，只不过现在不是问你 Next Greater Number 是多少，而是问你当前距离 Next Greater Number 的距离而已。</p>
<p>相同类型的问题，相同的思路，直接调用单调栈的算法模板，稍作改动就可以啦，直接上代码把。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) {
    vector&lt;int&gt; ans(T.size());
    stack&lt;int&gt; s; // 这里放元素索引，而不是元素
    for (int i = T.size() - 1; i &gt;= 0; i--) {
        while (!s.empty() &amp;&amp; T[s.top()] &lt;= T[i]) {
            s.pop();
        }
        ans[i] = s.empty() ? 0 : (s.top() - i); // 得到索引间距
        s.push(i); // 加入索引，而不是元素
    }
    return ans;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>单调栈讲解完毕。下面开始另一个重点：如何处理<strong>「循环数组」</strong>。</p>
<p>同样是 Next Greater Number，现在假设给你的数组是个环形的，如何处理？</p>
<p>给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,4]。拥有了环形属性，最后一个元素 3 绕了一圈后找到了比自己大的元素 4 。</p>
<p><img src="images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1598145576-FZfoUA-2.png" alt="ink-image"></p>
<p>首先，计算机的内存都是线性的，没有真正意义上的环形数组，但是我们可以模拟出环形数组的效果，一般是通过 % 运算符求模（余数），获得环形特效：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int[] arr = {1,2,3,4,5};
int n = arr.length, index = 0;
while (true) {
    print(arr[index % n]);
    index++;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>回到 Next Greater Number 的问题，增加了环形属性后，问题的难点在于：这个 Next 的意义不仅仅是当前元素的右边了，有可能出现在当前元素的左边（如上例）。</p>
<p>明确问题，问题就已经解决了一半了。我们可以考虑这样的思路：<strong>将原始数组“翻倍”，就是在后面再接一个原始数组</strong>，这样的话，按照之前“比身高”的流程，每个元素不仅可以比较自己右边的元素，而且也可以和左边的元素比较了。</p>
<img src="images/数据结构和算法/1598145576-qOHCdl-3.png" alt="ink-image (2)" style="zoom:80%;">

<p>不用重新构造一个两倍长度的数组，我们可以利用%来进行模拟循环</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; res(n); // 存放结果
    stack&lt;int&gt; s;
    // 假装这个数组长度翻倍了
    for (int i = 2 * n - 1; i &gt;= 0; i--) {
        while (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n])
            s.pop();
        res[i % n] = s.empty() ? -1 : s.top();
        s.push(nums[i % n]);
    }
    return res;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题2：1964-找出到每个位置为止最长的有效障碍赛跑路线"><a href="#例题2：1964-找出到每个位置为止最长的有效障碍赛跑路线" class="headerlink" title="例题2：1964. 找出到每个位置为止最长的有效障碍赛跑路线"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-longest-valid-obstacle-course-at-each-position/">1964. 找出到每个位置为止最长的有效障碍赛跑路线</a></h3><p>其实这题我们上面<strong>最长非降子序列</strong>那里的<strong>例题1</strong>里写过，就不再写了，可以上翻看看。</p>
<h3 id="例题3：42-接雨水"><a href="#例题3：42-接雨水" class="headerlink" title="例题3：42. 接雨水"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h3><img src="images/数据结构和算法/image-20211103124105561.png" alt="image-20211103124105561" style="zoom:80%;">

<p>这道题感觉有思路，但是不完全有。还是看来题解做出来的，对于困难题还是力不足啊。</p>
<p><strong>动态规划：</strong>它有多个解题思路，先来说说动态规划吧，话说好久没写动态规划了。</p>
<p>我们对于每一个下标i，找到它左边的最大值和右边的最大值，取这两个最大值中较小者，减去height[i]就是该点所能装的雨水（要分离的看，不要总体去看）; 所以找左右两侧最大值如果遍历的去找的话就会很浪费时间，所以我们可以用动态规划去找。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int n = height.size();
        vector&lt;int&gt; leftMax(n);
        vector&lt;int&gt; rightMax(n);
        leftMax[0] = height[0], rightMax[n - 1] = height[n - 1];
        
        int number = 0;
        for(int i = 1; i &lt; n; i++){
            leftMax[i] = max(leftMax[i - 1], height[i]);
        } 
        for(int i = n - 2; i &gt;= 0; i--){
            rightMax[i] = max(rightMax[i + 1], height[i]);
        }
        //确定好左右最大高度之后，就可以进行遍历的计算雨水了
        for(int i = 0; i &lt; n; i++){
            number += min(leftMax[i], rightMax[i]) - height[i];
        }
        return number;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>单调栈</strong>：我看到这题第一个想到的就是单调栈，但奈何没有后续了。</p>
<p>我们可以从头遍历，维护一个单调栈，保证从栈底到栈顶是递减的（这样就保证了右边比左边小，即top小于left）。对于下标i，当栈中有两个及以上的元素时，如果height[i] &gt; height[top]，那么就能够接雨水了。接雨水区域的高度 = min(height[i], height[left]) - height[top]，就把left和i当成两边，top是中间就行了。这样宽度也很明显 = i - left - 1.top搞完后，left就成了新的top，再与i进行比较。若还能接，那么重复操作直到栈为空或height[top] &gt;= height[i]。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int n = height.size();
        if(n == 0) return 0; 
        stack&lt;int&gt; st;
        int ans = 0;
        for(int i = 0; i &lt; n; i++){
            while(!st.empty() &amp;&amp; height[i] &gt; height[st.top()]){
                int index = st.top();
                st.pop();
                if(st.empty()) break;

                int left = st.top();
                int currWidth = i - left - 1;
                int currHeight = min(height[i], height[left]) - height[index];
                ans += currHeight * currWidth;
            }
            st.push(i);
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>双指针：双指针的思路其实和上面动态规划的思路差不多，只不过是用两个变量代替了数组，空间复杂度下降到了O（1）</p>
<p>我们定义left 和 right指针，同时更新leftMax 和 rightMax两个变量。当两指针没有相遇时：</p>
<p>若height[left] &lt; height[right]，那么 leftMax 必定小于 rightMax，所以该left 处所能接的雨水位leftMax - height[left]。</p>
<p>若height[left]&gt;=height[right]，那么 rightMax必定小于leftMax，所以该right处所能接的雨水位rightMax- height[right]。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int n = height.size();
        if(n == 0) return 0;
        int left = 0, right = n - 1;
        int leftMax = 0, rightMax = 0;
        int ans = 0;
        while(left &lt;= right){
            leftMax = max(leftMax, height[left]);
            rightMax = max(rightMax, height[right]);

            if(height[left] &gt; height[right]){
                //leftMax &gt; rightMax
                ans += rightMax - height[right];
                right--;
            }
            else{
                //rightMax &gt; leftMax
                ans += leftMax - height[left];
                left++;
            }
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题4：407-接雨水-II"><a href="#例题4：407-接雨水-II" class="headerlink" title="例题4：407. 接雨水 II"></a>例题4：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water-ii/">407. 接雨水 II</a></h3><img src="images/数据结构和算法/image-20211103201255947.png" alt="image-20211103201255947" style="zoom:80%;">

<p>这题是上一题的升级版，三维维度接雨水，爱了爱了😂🤣。</p>
<p>直接上官方的解题思路吧：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water-ii/solution/jie-yu-shui-ii-by-leetcode-solution-vlj3/">接雨水 II - 接雨水 II - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>自己也写了一遍：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef pair&lt;int, int&gt; pii;
class Solution {
public:
    int trapRainWater(vector&lt;vector&lt;int&gt;&gt;&amp; heightMap) {
        int m = heightMap.size(), n = heightMap[0].size();
        if(m &lt;= 2 || n &lt;= 2) return 0;
        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;
        vector&lt;vector&lt;bool&gt;&gt; visit(m, vector&lt;bool&gt;(n, false));
        int res = 0;
        for(int i = 0; i &lt; m; i++){
            for(int j = 0; j &lt; n; j++){
                if(i == 0 || i == m - 1 || j == 0 || j == n - 1){
                    q.push({heightMap[i][j], i * n + j});
                    visit[i][j] = true;
                }
            }
        }
        //这个方向数组用的妙呀！！！
        int dir[] = {-1, 0, 1, 0, -1};
        while(!q.empty()){
            pii cur = q.top();
            q.pop();
            for(int k = 0; k &lt; 4; k++){
                int nx = cur.second / n + dir[k];
                int ny = cur.second % n + dir[k + 1];
                if(0 &lt;= nx &amp;&amp; nx &lt; m &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n &amp;&amp; !visit[nx][ny]){
                    if(heightMap[nx][ny] &lt; cur.first){
                        res += cur.first - heightMap[nx][ny];
                    }
                    q.push({max(cur.first, heightMap[nx][ny]), nx * n + ny});
                    visit[nx][ny] = true;
                }
            }
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p><strong>刚才看到了一个判断一个数是否是2的幂的方法，真的不错</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool isPowerOfTwo(int n) {
	return (n &amp; (n - 1)) == 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="例题1：470-用-Rand7-实现-Rand10"><a href="#例题1：470-用-Rand7-实现-Rand10" class="headerlink" title="例题1：470. 用 Rand7() 实现 Rand10()"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210901095737479.png" alt="image-20210901095737479" style="zoom:80%;">

<p>这题一开始看到是没有思路的，题解区又有个大佬写的题解非常好，我放在这了</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/">从最基础的讲起如何做到均匀的生成随机数 - 用 Rand7() 实现 Rand10() - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>我们可以利用那些超范围的值进行优化，提高找到随机数的命中率。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// The rand7() API is already defined for you.
// int rand7();
// @return a random integer in the range 1 to 7

class Solution {
public:
    int rand10() {
        while(true){
            int a = rand7();
            int b = rand7();
            int num = (a - 1) * 7 + b;  //rand49
            //拒绝采样
            if(num &lt;= 40) return num % 10 + 1;

            a = num - 40;         //rand9
            b = rand7();
            num = (a - 1) * 7 + b; //rand63
            if(num &lt;= 60) return num % 10 + 1;

            a = num - 60;       //rand3
            b = rand7();
            num = (a - 1) * 7 + b;  //rand21
            if(num &lt;= 20) return num % 10 + 1;
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题2：LCP-46-志愿者调配"><a href="#例题2：LCP-46-志愿者调配" class="headerlink" title="例题2：LCP 46. 志愿者调配"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/05ZEDJ/">LCP 46. 志愿者调配</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210925222852909.png" alt="image-20210925222852909" style="zoom:80%;">

<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210925222911289.png" alt="image-20210925222911289" style="zoom:80%;">

<p>这题就充分体现了数学的重要性啊，应该早点复习线性代数的。</p>
<img src="D:\QQ下载文件\1414521825\FileRecv\MobileFile\IMG_20210925_223326.jpg" alt="IMG_20210925_223326" style="zoom:67%;">

<p>所以我们可以设置这两个数组进行逆向操作，最后怎么求 x 呢？我们可以把逆向操作后的数组求和，那么左边就是总人数，右边就是 x * w1的总人数 + w2的总人数，那么 x 就好求了。</p>
<p>额外要注意的一点是我们求和的时候得设置为long long变量，否则会溢出。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
class Solution {
public:
    vector&lt;int&gt; volunteerDeployment(vector&lt;int&gt;&amp; finalCnt, long long totalNum, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;vector&lt;int&gt;&gt;&amp; plans) {
        int w1[50001]  {0};
        int w2[50001]  {0};
        int n = finalCnt.size() + 1;
        //初始化工作
        w1[0] = 1;
        for(int i = 1; i &lt; n; i++){
            w2[i] = finalCnt[i - 1];
        }
        //初始化图
        //vector&lt;int&gt; grid[n];也可以
        unordered_map&lt;int, vector&lt;int&gt;&gt; grid;
        for(auto&amp; edge : edges){
            grid[edge[0]].push_back(edge[1]);
            grid[edge[1]].push_back(edge[0]);
        }
        //接下来进行逆操作
        for(int i = plans.size() - 1; i &gt;= 0; i--){
            int num = plans[i][0];
            int idx = plans[i][1];
            if(num == 1){
                w1[idx] *= 2;
                w2[idx] *= 2;
            }
            else if(num == 2){
                for(int id : grid[idx]){
                    w1[id] -= w1[idx];
                    w2[id] -= w2[idx];
                }
            }
            else{
                for(int id : grid[idx]){
                    w1[id] += w1[idx];
                    w2[id] += w2[idx];
                }
            }
        }
        long long sum1 = 0, sum2 = 0;
        for(int w : w1) sum1 += w;
        for(int w : w2) sum2 += w;
        int x = (totalNum - sum2) / sum1;
        vector&lt;int&gt; res(n);
        for(int i = 0; i &lt; n; i++){
            res[i] = x * w1[i] + w2[i];
        }
        return res;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题3：166-分数到小数"><a href="#例题3：166-分数到小数" class="headerlink" title="例题3：166. 分数到小数"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/">166. 分数到小数</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211004141849994.png" alt="image-20211004141849994" style="zoom:80%;">

<p>这是一道<strong>模拟除法</strong>的题目（￣︶￣）↗　，我们可以用哈希表存储每次出现的余数在字符串中的下标，如果出现的话那么就一定开始了循环，所以就可以给下标位置加 ‘ ( ‘，最后的位置加右括号。</p>
<p>要注意的点就是如果是-2147483648 / -1的话，会超出int 类型的范围，所以我们要事先转化成long long类型。</p>
<p>整体来说还是挺不错的一道题，第一次没做出来呀。/(ㄒoㄒ)/~~</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        long long a = numerator, b = denominator;
        if(a % b == 0) return to_string(a / b);
        string ans = "";
        if(a * b &lt; 0) ans += '-';
        a = abs(a);
        b = abs(b);
        ans += to_string(a / b) + '.';
        a = a % b;
        unordered_map&lt;int, int&gt; table;
        while(a != 0){
            table[a] = ans.length();
            a *= 10;
            ans += to_string(a / b);
            a = a % b;
            if(table.count(a)){
                int index = table[a];
                return ans.substr(0, index) + '(' +  ans.substr(index) + ')';
            }
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题4：384-打乱数组"><a href="#例题4：384-打乱数组" class="headerlink" title="例题4：384. 打乱数组"></a>例题4：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shuffle-an-array/">384. 打乱数组</a></h3><img src="images/数据结构和算法/image-20211122125410923.png" alt="image-20211122125410923" style="zoom:80%;">

<p>这题可以用经典的洗牌算法，我们可以先选n张牌中的一张到第一个位置，然后从剩下的n - 1张牌中选一张到第二个位置，依次类推。</p>
<p>证明就放在这了：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode-solution-og5u/">打乱数组 - 打乱数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    Solution(vector&lt;int&gt;&amp; nums) {
        res = nums;
    }
    
    vector&lt;int&gt; reset() {
        return res;
    }
    
    vector&lt;int&gt; shuffle() {
        vector&lt;int&gt; ans = res;
        int n = ans.size();
        for(int i = 0; i &lt; n; i++){
            int k = i + rand() % (n - i);
            swap(ans[i], ans[k]);
        }
        return ans;
    }
private:
    vector&lt;int&gt; res;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * vector&lt;int&gt; param_1 = obj-&gt;reset();
 * vector&lt;int&gt; param_2 = obj-&gt;shuffle();
 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="例题1：1998-数组的最大公因数排序"><a href="#例题1：1998-数组的最大公因数排序" class="headerlink" title="例题1：1998. 数组的最大公因数排序"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gcd-sort-of-an-array/">1998. 数组的最大公因数排序</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210906215211383.png" alt="image-20210906215211383" style="zoom:80%;">

<p>这题我们可以考虑把每个数与他的质因数连通起来，然后与排序后的数组进行比较，相同的数字跳过，否则比较是否在一个连通分量里面，这题就涉及到并查集了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">const int N = 1e5 + 10;
class Solution {
public:
    int parent[N];
    int find(int x){
        while(x != parent[x]){
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
    void Union(int x, int y){
        int root_x = find(x);
        int root_y = find(y);
        if(root_x == root_y) return;
        parent[root_x] = root_y;
    }
    bool gcdSort(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; nums0 = nums;
        for(int i = 1; i &lt; N; i++) parent[i] = i;
        //分解质因数
        //这里一开始我写的是 int&amp; c，但是这样改变了nums数组
        for(int c : nums){
            int k = c;
            for(int i = 2; i &lt;= c / i; i++){
                bool flag = false;
                while(c % i == 0){
                    c /= i;
                    flag = true;
                }
                if(flag) Union(k, i);
            }
            if(c &gt; 1) Union(k, c);
        }
        sort(nums0.begin(), nums0.end());
        for(int i = 0; i &lt; nums.size(); i++){
            if(nums[i] == nums0[i]) continue;
            if(find(nums0[i]) != find(nums[i])){
                return false;
            }
        }
        return true;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题2：352-将数据流变为多个不相交区间"><a href="#例题2：352-将数据流变为多个不相交区间" class="headerlink" title="例题2：352. 将数据流变为多个不相交区间"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/">352. 将数据流变为多个不相交区间</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211009133015773.png" alt="image-20211009133015773" style="zoom:80%;">

<p>这道题，感觉不算困难，可能是没考虑进阶吧，直接暴力遍历一遍就行了，不过得事先排好序。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class SummaryRanges {
public:
    vector&lt;int&gt; nums;
    SummaryRanges() {
        
    }
    
    void addNum(int val) {
        nums.push_back(val);
    }
    
    vector&lt;vector&lt;int&gt;&gt; getIntervals() {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; ans(2);
        ans[0] = nums[0];
        for(int i = 1; i &lt; n; i++){
            if(nums[i] - nums[i - 1] &gt; 1){
                ans[1] = nums[i - 1];
                res.push_back(ans);
                ans[0] = nums[i];
            }
            else{
                ans[1] = nums[i];
            }
        }
        ans[1] = nums[n - 1];
        res.push_back(ans);
        return res;
    }
};

/**
 * Your SummaryRanges object will be instantiated and called as such:
 * SummaryRanges* obj = new SummaryRanges();
 * obj-&gt;addNum(val);
 * vector&lt;vector&lt;int&gt;&gt; param_2 = obj-&gt;getIntervals();
 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这道题还很适合并查集，我们可以让父节点表示右边界。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class SummaryRanges {
public:
    //设计到区间，还可以用并查集来写
    const static int MAXN = 1e4 + 50;
    int parent[MAXN];
    set&lt;int&gt; nums;
    SummaryRanges() {
        for(int i = 0; i &lt; MAXN; i++) parent[i] = i;
    }
    
    void addNum(int val) {
        nums.insert(val);
        parent[val] = parent[val + 1];
    }
    
    vector&lt;vector&lt;int&gt;&gt; getIntervals() {
        vector&lt;vector&lt;int&gt;&gt; res;
        for(int num : nums){
            if(!res.empty() &amp;&amp; res.back()[1] &gt;= num) continue;
            res.push_back({num, find(num) - 1});
        }
        return res;
    }

    int find(int x){
        while(x != parent[x]){
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这是优化之后的并查集，当数据量特别大时，我们这个算法就很占优势了，因为以前的信息都保存了下来。直接查就行了</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int MAXN = 1e4 + 50;
class SummaryRanges {
public:
    set&lt;int&gt; nums;
    int parent[MAXN];
    SummaryRanges() {
        for(int i = 0; i &lt; MAXN; i++) parent[i] = -1;
    }
    
    void addNum(int val) {
        if(parent[val] == -1){
            nums.insert(val);
            parent[val] = val;
            //合并右边，再合并左边
            Union(val, val + 1);
            Union(val - 1, val);
        }
    }
    
    vector&lt;vector&lt;int&gt;&gt; getIntervals() {
        vector&lt;vector&lt;int&gt;&gt; res;
        for(int start : nums){
            int end = Find(start);
            res.push_back({start, end});
        }
        return res;
    }

    int Find(int x){
        /*
        if (parent[x] != x) return parent[x] = Find(parent[x]);
        return parent[x];
        */
        while(x!=parent[x]){
			parent[x] = parent[parent[x]];
			x=parent[x];
		}
		return x;
    }
    void Union(int x, int y){
        if(x &gt;= 0 &amp;&amp; x &lt;= 10000 &amp;&amp; parent[x] != -1 &amp;&amp; parent[y] != -1){
            int root_x = Find(x);
            int root_y = Find(y);
            if(root_x != root_y)
                parent[root_x] = root_y; 
                //合并之后得删掉y，y就成了断点
                nums.erase(y);
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="例题1：5892-石子游戏-IX"><a href="#例题1：5892-石子游戏-IX" class="headerlink" title="例题1：5892. 石子游戏 IX"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/stone-game-ix/">5892. 石子游戏 IX</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211004130159564.png" alt="image-20211004130159564" style="zoom:80%;">

<p>这道题有个条件很重要，移出的数的总和能被3整除就输掉比赛，我们可以对所有的数进行余3操作，因为余3和对于结果没有影响。</p>
<p>所以能取的数就只有三个了：0，1，2；取0是不影响比赛结果的，因为如果目前移出的数总和是1，那么Alice取1和0都是一样的。比如Alice取1，那么结果是2，bob取0，下一回合还是Alice的2；那如果Alice取0，那么bob取1，结果为2，下一回合还是Alice遇到2。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int cnt[3], mem[3];
class Solution {
public:
    bool check(int x){
        for(int i = 0; i &lt; 3; i++) mem[i] = cnt[i];
        //如果第一个要取的都没有，那么Alice就输了呀
        if(mem[x] == 0) return false;
        mem[x]--;
        //表示这是bob的回合
        int turn = 1;
        //表示当前移除的数的余数
        int cur = x;
        //接下来就是进行循环模拟
        while(true){
            if(mem[0] &gt; 0){
                mem[0]--;
            }
            else if(mem[cur] &gt; 0){
                mem[cur]--;
                cur = (cur + cur) % 3;  
            }
            else break;
            turn = 1 - turn;
        }
        //如果石子都用完了，那么bob就赢了
        if(mem[0] + mem[1] + mem[2] == 0) return false;
        return turn == 1;
    }
    bool stoneGameIX(vector&lt;int&gt;&amp; stones) {
        int n = stones.size();
        memset(cnt, 0, sizeof(cnt));
        for(int i = 0; i &lt; n; i++){
            cnt[stones[i] % 3]++;
        }
        //Alice先手，那就只能取 1或2，所以我们直接判断取 1或2的胜负情况就行了
        if(check(1) || check(2)) return true;
        return false;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><h3 id="例题1：36-有效的数独"><a href="#例题1：36-有效的数独" class="headerlink" title="例题1：36. 有效的数独"></a>例题1：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-sudoku/">36. 有效的数独</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210917112125112.png" alt="image-20210917112125112" style="zoom:80%;">

<p>这题一开始我是直接暴力的，暴力代码还是好写的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int dict[8][2] =  {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        unordered_map&lt;char, int&gt; nums;
        //判断行
        for(int i = 0; i &lt; 9; i++){
            nums.clear();
            for(int j = 0; j &lt; 9; j++){
                if(board[i][j] != '.')
                    nums[board[i][j]]++;
                if(nums[board[i][j]] &gt; 1) return false;
            }
        }
        //判断列
        for(int i = 0; i &lt; 9; i++){
            nums.clear();
            for(int j = 0; j &lt; 9; j++){
                if(board[j][i] != '.')
                    nums[board[j][i]]++;
                if(nums[board[j][i]] &gt; 1) return false;
            }
        }
        //判断9宫格
        for(int i = 1; i &lt; 8; i += 3){
            for(int j = 1; j &lt; 8; j += 3){
                nums.clear();
                if(board[i][j] != '.')
                    nums[board[i][j]]++;
                for(int k = 0; k &lt; 8; k++){
                    if(board[i + dict[k][0]][j + dict[k][1]] != '.')
                    nums[board[i + dict[k][0]][j + dict[k][1]]]++;
                    if(nums[board[i + dict[k][0]][j + dict[k][1]]] &gt; 1){
                        return false;
                    } 
                }
            }
        }
        return true;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其实还可以用区间划分的方法一次遍历来查找是否有重复的数字</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">row[9][9] row[i][j]表示i行数j的出现情况（j是原来的数字减一了）
col[9][9]同理
主要还是9宫格，9宫格里同样是9个数字，那么考虑如何把它的下标化成一维来表示
9宫格我们按照从左到右，从上到下来表示
第一个 j = 0~2  i = 0~2
第二个 j = 3~5  i = 0~2
第三个	j = 5~8  i = 0~2
第四个 j = 0~2  i = 3~5
所以观察可知同一行的9宫格的下标由j控制，为j/3
那么下一行的9宫格下标就可以由i来控制，为(i/3)*3
所以总的下标为 j/3 + (i/3)*3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码如下：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        vector&lt;vector&lt;bool&gt;&gt; row(9, vector&lt;bool&gt;(9, false));
        vector&lt;vector&lt;bool&gt;&gt; col(9, vector&lt;bool&gt;(9, false));
        vector&lt;vector&lt;bool&gt;&gt; box(9, vector&lt;bool&gt;(9, false));
        for(int i = 0; i &lt; 9; i++){
            for(int j = 0; j &lt; 9; j++){
                if(board[i][j] == '.') continue;
                int indexBox = j / 3 + (i / 3) * 3;
                int cur = board[i][j] - '1';
                if(row[i][cur]) return false;
                if(col[j][cur]) return false;
                if(box[indexBox][cur]) return false;
                row[i][cur] = true;
                col[j][cur] = true;
                box[indexBox][cur] = true;
            }
        }
        return true;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题2：5877-检测正方形"><a href="#例题2：5877-检测正方形" class="headerlink" title="例题2：5877. 检测正方形"></a>例题2：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/detect-squares/">5877. 检测正方形</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210919132339494.png" alt="image-20210919132339494" style="zoom:80%;">

<p>我们遍历所有情况1000 * 5000 * 4 = 2* 10^7，数据量还算正常，可以暴力。</p>
<p>我们考虑以该point为定点，遍历边的边长，来找边长为 l（这里是小写的L） 的正方形的个数，它的个数就是其余3个点的个数之积</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int MAXN = 1001;
int nums[MAXN][MAXN];
class DetectSquares {
public:
    DetectSquares() {
        for(int i = 0; i &lt; MAXN; i++){
            for(int j = 0; j &lt; MAXN; j++){
                nums[i][j] = 0;
            }
        }
    }

    void add(vector&lt;int&gt; point) {
        nums[point[0]][point[1]] += 1;
    }
    
    int countSqure(int x, int y, int x0, int y0){
        int ans = 1;
        ans = ans * nums[x0][y];
        ans = ans * nums[x][y0];
        ans = ans * nums[x0][y0];
        return ans;
    }

    int count(vector&lt;int&gt; point) {
        //我们可以以该点遍历所有的长度的可能情况，有四个方向
        int res = 0;
        int x = point[0], y = point[1];
        for(int l = 1; l &lt; MAXN; l++){
            if(x - l &lt; 0 || y - l &lt; 0) break;
            res += countSqure(x, y, x - l, y - l);
        }
        for(int l = 1; l &lt; MAXN; l++){
            if(x - l &lt; 0 || y + l &gt;= MAXN) break;
            res += countSqure(x, y, x - l, y + l);
        }
        for(int l = 1; l &lt; MAXN; l++){
            if(x + l &gt;= MAXN || y - l &lt; 0) break;
            res += countSqure(x, y, x + l, y - l);
        }
        for(int l = 1; l &lt; MAXN; l++){
            if(x + l &gt;= MAXN || y + l &gt;= MAXN) break;
            res += countSqure(x, y, x + l, y + l);
        }
        return res;
    }
};

/**
 * Your DetectSquares object will be instantiated and called as such:
 * DetectSquares* obj = new DetectSquares();
 * obj-&gt;add(point);
 * int param_2 = obj-&gt;count(point);
 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="例题3：5878-重复-K-次的最长子序列"><a href="#例题3：5878-重复-K-次的最长子序列" class="headerlink" title="例题3：5878. 重复 K 次的最长子序列"></a>例题3：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-subsequence-repeated-k-times/">5878. 重复 K 次的最长子序列</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210919132415118.png" alt="image-20210919132415118" style="zoom:80%;">

<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210919132432468.png" alt="image-20210919132432468" style="zoom:80%;">

<p>对于这道题我一开始是真的没思路，比赛打完了看了坑神的视频才明白，原来暴力就行，tql</p>
<p>其实这题还是有提示的，2 &lt;= n &lt; k * 8，所以这个重复k次的子序列的长度不会超过8，即长度为1~7</p>
<p>所以我们可以遍历长度为1~7的所有情况，把长度为len的所有子序列都遍历一遍，每个遍历26次，每次对应一个字母，当然从大大小，因为长度相同时要返回字典序最大的那个子序列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//其实这里我还不知道可以这么搞，学到了
vector&lt;string&gt; savAns[8];
class Solution {
public:
    //检验这个子序列s0是否在s中重复了k次
    bool check(const string&amp; s,const string&amp; s0, int k){
        int n = s.size();
        int m = s0.size();
        int j = 0, target = m * k;
        for(int i = 0; i &lt; n &amp;&amp; j &lt; target; i++){
            if(s[i] == s0[j % m]) j++;
        }
        return j == target;
    }
    string longestSubsequenceRepeatedK(string s, int k) {
        for(int i = 0; i &lt; 8; i++) savAns[i].clear();
        savAns[0].push_back("");
        //注意到 2 &lt;= n &lt; k * 8，说明重复k次子序列的长度不会超过7（1~7）
        //所有我们可以从长度为1的子序列开始遍历
        for(int len = 1; len &lt;= 7; len++){
            //因为相同长度的字符串还要按照字典序大的返回，所有我们遍历时就按照字典序大的情况遍历
            for(string&amp; cur : savAns[len - 1]){
                //把26个字母都加到cur子序列上试一试，看看满不满足出现k次的要求
                for(char c = 'z'; c &gt;= 'a'; c--){
                    string nxt = cur + c;
                    if(check(s, nxt, k)){
                        savAns[len].push_back(nxt);
                    }
                }
            }
        }
        //最后我们在从最长的子序列中找出字典序最大的那个
        for(int i = 7; i &gt;= 1; i--){
            if(savAns[i].size() &gt; 0) return savAns[i][0];
        }
        return "";
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题4：5882-网格游戏"><a href="#例题4：5882-网格游戏" class="headerlink" title="例题4：5882. 网格游戏"></a>例题4：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/grid-game/">5882. 网格游戏</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20210926125722070.png" alt="image-20210926125722070" style="zoom:80%;">

<p>这是周赛的第二题，我理解错意思了，我已经第一个机器人是要找最大值，结果显然没做出来。</p>
<p>我们保证第一个机器人是要阻止第二个机器人取得最大值的</p>
<p>那我们把视线移到第二个机器人身上，我们发现它的值与第一个机器人的拐点有关。它只能取拐点的右边的值，或拐点下方的左边的值，好好理解一下。那我们就可以用两个数组存储前缀和和后缀和，这样方便取左边或右边的值。</p>
<p>我们遍历每一个拐点，取最大左右值中最小的那个。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    long long gridGame(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        //第一个机器人不是选择最大的，而是阻止第二个机器人选择最大的
        int n = grid[0].size();
        vector&lt;vector&lt;long long&gt;&gt; dp(2, vector&lt;long long&gt;(n, 0));
        long long ans = LONG_MAX;
        //计算前缀和
        for(int i = 1; i &lt; n; i++){
            dp[1][i] = dp[1][i - 1] + grid[1][i - 1];
        }
        for(int i = n - 2; i &gt;= 0; i--){
            dp[0][i] = dp[0][i + 1] + grid[0][i + 1];
        }
        for(int i = 0; i &lt; n; i++){
            long long sum_left = dp[1][i];
            long long sum_right = dp[0][i];
            ans = min(ans, max(sum_left, sum_right));
        }
        eturn ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="例题5：391-完美矩形"><a href="#例题5：391-完美矩形" class="headerlink" title="例题5：391. 完美矩形"></a>例题5：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-rectangle/">391. 完美矩形</a></h3><img src="images/数据结构和算法/image-20211116125329181.png" alt="image-20211116125329181" style="zoom:80%;">

<img src="images/数据结构和算法/image-20211116125353466.png" alt="image-20211116125353466" style="zoom:80%;">

<img src="images/数据结构和算法/image-20211116125407353.png" alt="image-20211116125407353" style="zoom:80%;">

<p>这题我个人觉得还是考思维啊，我们可以记录每个坐标，相同的坐标消掉，构成完美矩阵，那么最终只剩下4个坐标。同时我们记录每个小矩阵的面积之和，最终与那4个坐标构成的大矩阵面积进行比较，相同则为完美矩阵，否则不是。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LL long long
class Solution {
public:
    bool isRectangleCover(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) {
        LL area = 0;
        map&lt;pair&lt;int, int&gt;, int&gt; points;
        for(vector&lt;int&gt;&amp; r : rectangles){
            area += (r[2] - r[0]) * (r[3] - r[1]);
            points[{r[0], r[1]}]++;
            points[{r[0], r[3]}]++;
            points[{r[2], r[1]}]++;
            points[{r[2], r[3]}]++;
        }
        vector&lt;pair&lt;int, int&gt;&gt; ans;
        for(auto&amp; m : points){
            if(m.second % 2 == 1){
                ans.push_back(m.first);
            }
        }
        if(ans.size() != 4) return false;
        sort(ans.begin(), ans.end());
        LL area0 = (ans[3].first - ans[0].first) * (ans[3].second - ans[0].second);
        for(int i = 0; i &lt; 4; i++) cout&lt;&lt;ans[i].first&lt;&lt;" "&lt;&lt;ans[i].second&lt;&lt;endl;
        cout&lt;&lt;area&lt;&lt;" "&lt;&lt;area0&lt;&lt;endl;
        return area == area0;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这题还可以用常规的算法扫描线来做，不过意思好理解，但代码实现有点复杂，后面再处理吧。</p>
<h1 id="力扣周赛"><a href="#力扣周赛" class="headerlink" title="力扣周赛"></a>力扣周赛</h1><h2 id="第262场周赛"><a href="#第262场周赛" class="headerlink" title="第262场周赛"></a>第262场周赛</h2><p>这次周赛只写出一道题，太菜了哈哈哈，不过没关系，也学到了很多。下次肯定不会了..吧？额，应该不会。</p>
<h3 id="5895-获取单值网格的最小操作数"><a href="#5895-获取单值网格的最小操作数" class="headerlink" title="5895. 获取单值网格的最小操作数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid/">5895. 获取单值网格的最小操作数</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211010135650647.png" alt="image-20211010135650647" style="zoom:80%;">

<p>这题卡了好就，没想到暴力没和数，还是做少了呀。前缀和的应用</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LL long long
const int INF = 2e9;
class Solution {
public:
    int minOperations(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x) {
        int m = grid.size(), n = grid[0].size();
        int mi = grid[0][0], mx = grid[0][0];
        //找出网格中的最大最小值
        for(int i = 0; i &lt; m; i++){
            for(int j = 0; j &lt; n; j++){
                mi = min(mi, grid[i][j]);
                mx = max(mx, grid[i][j]);
            }
        }
        vector&lt;int&gt; nums;
        //判断是否能化成相等的数,可以用网格中任何一个数字与其他数字相减，看结果能否被 x 整除
        for(int i = 0; i &lt; m; i++){
            for(int j = 0; j &lt; n; j++){
                if((grid[i][j] - mi) % x != 0) return -1;
                //把最小数化成每个数的次数放入数组
                nums.push_back((grid[i][j] - mi) / x);
            }
        }
        sort(nums.begin(), nums.end());
        /*
        我们可以这样想，题目是要求化成相等数的最小次数，那么不就是把nums数组中的数都化成相等的数的最小次数吗
        而且对nums的操作就是+1、-1了，所以我们可以利用前缀和来进行简化运算
        */
        int N = nums.size();
        int sum[N + 1];
        sum[0] = 0; for(int i = 1; i &lt;= N; i++) sum[i] = sum[i - 1] + nums[i - 1];

        LL ans = INF;
        int p = 0;
        //接下来遍历所有的情况，可以是 mi 到 mx 间的任何一个数
        for(int k = 0, lim = (mx - mi) / x; k &lt;= lim; k++){
            //需要找到小于等于k的最后一个数的坐标，再利用前缀和来求操作数
            while(p + 1 &lt; N &amp;&amp; nums[p + 1] &lt;= k) p++;
            //前部分 + 后部分
            ans = min(ans, 1LL * k * (p + 1) - sum[p + 1] + sum[N] - sum[p + 1] - 1LL * k * (N - p - 1));
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5896-股票价格波动"><a href="#5896-股票价格波动" class="headerlink" title="5896. 股票价格波动"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/stock-price-fluctuation/">5896. 股票价格波动</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211010140019358.png" alt="image-20211010140019358" style="zoom:80%;">

<p>这题当时做出来，但超时了，其实可以利用优先队列的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define PII pair&lt;int, int&gt;
class StockPrice {
public:
    unordered_map&lt;int, int&gt; mem;
    priority_queue&lt;PII&gt; mi;
    priority_queue&lt;PII&gt; mx;
    //用来保存最新的时间戳，方便后面取数据
    int last;
    StockPrice() {
        //初始化操作，清空
        last = -1;
        mem.clear();
        while(!mi.empty()) mi.pop();
        while(!mx.empty()) mx.pop();
    }
    
    void update(int timestamp, int price) {
        mem[timestamp] = price;
        last = max(timestamp, last);
        mi.push({-price, timestamp});
        mx.push({price, timestamp});
    }
    
    int current() {
        return mem[last];
    }
    
    int maximum() {
        //先判处失效的时间戳的股票
        while(true){
            PII x = mx.top();
            if (mem[x.second] != x.first){
                mx.pop();
            } else break;
        }
        return mx.top().first;
    }
    
    int minimum() {
        //先判处失效的时间戳的股票
        while(true){
            PII x = mi.top();
            if(mem[x.second] != -x.first){
                mi.pop();
            } else break;
        }
        return -mi.top().first;
    }
};

/**
 * Your StockPrice object will be instantiated and called as such:
 * StockPrice* obj = new StockPrice();
 * obj-&gt;update(timestamp,price);
 * int param_2 = obj-&gt;current();
 * int param_3 = obj-&gt;maximum(); 
 * int param_4 = obj-&gt;minimum();
 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5897-将数组分成两个数组并最小化数组和的差"><a href="#5897-将数组分成两个数组并最小化数组和的差" class="headerlink" title="5897. 将数组分成两个数组并最小化数组和的差"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/">5897. 将数组分成两个数组并最小化数组和的差</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211010141715939.png" alt="image-20211010141715939" style="zoom:80%;">

<p>这道题感觉还是难啊，看来视频也是好久才看懂。用到了meet in the middle，还是很复杂啊。</p>
<p>先写一下库函数的用法吧，有点忘了</p>
<blockquote>
<p>lower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。</p>
<p>在从小到大的排序数组中，</p>
<p>lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p>upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p>在从大到小的排序数组中，重载lower_bound()和upper_bound()</p>
<p>lower_bound( begin,end,num,greater&lt; type&gt;() ):从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p>upper_bound( begin,end,num,greater&lt; type&gt;() ):从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LL long long
//delta[i]表示前半区，有 i 个元素属于 array1，那么array1 与 array2的查值的绝对值为 delta[i]
vector&lt;LL&gt; delta[16];
class Solution {
public:
    int minimumDifference(vector&lt;int&gt;&amp; nums) {
        int N = nums.size();
        int n = N / 2;
        for(int i = 0; i &lt;= n; i++) delta[i].clear();
        //用二进制遍历所有的情况，即 0 表示不在 array1，1 表示在
        int lim = 1 &lt;&lt; n;
        for(int s = 0; s &lt; lim; s++){
            int c = 0;
            LL sum = 0;
            for(int i = 0; i &lt; n; i++){
                if((s &gt;&gt; i) &amp; 1){
                    c += 1;
                    sum += nums[i];
                }
                else{
                    //在array2 就减去它
                    sum -= nums[i];
                }
            }
            delta[c].push_back(sum);
        }
        //算一个可行的解，方便后面进行比较
        LL ans = 0; for(int i = 0; i &lt; n; i++) ans += nums[i] - nums[n + i]; ans = abs(ans);
        //排好序，方便后面进行查找
        for(int i = 0; i &lt;= n; i++) sort(delta[i].begin(), delta[i].end());
        //进行右半区的查解，再与左半区合并
        for(int s = 0; s &lt; lim; s++){
            int c = 0;
            LL sum = 0;
            for(int i = 0; i &lt; n; i++){
                if((s &gt;&gt; i) &amp; 1){
                    c += 1;
                    sum += nums[n + i];
                }
                else{
                    //在array2 就减去它
                    sum -= nums[n + i];
                }
            }
            //因为array1的长度为n，所以右半区array1长度为c的情况下，左半区为n - c
            int nc = n - c;
            //在左半区内找delta[nc]里与 -sum 最接近的，因为要相加绝对值最小嘛，所以是-sum
            vector&lt;LL&gt;::iterator p =  upper_bound(delta[nc].begin(), delta[nc].end(), -sum);
            //这里是把最接近-sum的两边的值进行比较
            if(p != delta[nc].end()) ans = min(ans, abs(*p + sum));
            if(p != delta[nc].begin()) ans = min(ans, abs(*(p - 1) + sum));
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="第263场周赛"><a href="#第263场周赛" class="headerlink" title="第263场周赛"></a>第263场周赛</h2><p>这次周赛感觉是不是简单一点。</p>
<h3 id="2044-统计按位或能得到最大值的子集数目"><a href="#2044-统计按位或能得到最大值的子集数目" class="headerlink" title="2044. 统计按位或能得到最大值的子集数目"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">2044. 统计按位或能得到最大值的子集数目</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211018130015199.png" alt="image-20211018130015199" style="zoom:80%;">

<p>这题比赛时我用的二进制枚举，数据量不算很大，过了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int countMaxOrSubsets(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int len = 1 &lt;&lt; n;
        int cnt = 0;
        int ans = INT_MIN;
        int num = 0;
        int count;
        for(int i = 1; i &lt; len; i++){
            num = 0;
            count = 0;
            int k = i;
            while(k){
                if(k &amp; 1){
                    num = num | nums[count];
                }
                k &gt;&gt;= 1;
                count++;
            }
            if(ans &lt; num){
                ans = num;
                cnt = 1;
            }
            else if(ans == num){
                cnt++;
            }
        }
        return cnt;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2045-到达目的地的第二短时间"><a href="#2045-到达目的地的第二短时间" class="headerlink" title="2045. 到达目的地的第二短时间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/">2045. 到达目的地的第二短时间</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211018130218786.png" alt="image-20211018130218786" style="zoom:80%;">

<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211018130241139.png" alt="image-20211018130241139" style="zoom:80%;">

<p>这题我想的就是先把次短路径找出来，然后进行模拟，不过超时了。。。</p>
<p>下面这个是我看的一个大佬的题解，写的很清晰，但感觉我理解的不清晰/(ㄒoㄒ)/~~</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    unordered_map&lt;int, int&gt; fast; //记录第一次达到
    unordered_map&lt;int, int&gt; second;  //记录第二次到达
    int secondMinimum(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int time, int change) {
        unordered_map&lt;int, vector&lt;int&gt;&gt; grid;
        queue&lt;pair&lt;int, int&gt;&gt; q; //存储节点和到达该节点的时间
        q.push({1, 0});
        int first = -1;

        for(auto&amp; edge : edges){
            if (grid.find(edge[0]) == grid.end()) grid[edge[0]] = vector&lt;int&gt;(0);
            if (grid.find(edge[1]) == grid.end()) grid[edge[1]] = vector&lt;int&gt;(0);
            grid[edge[0]].push_back(edge[1]);
            grid[edge[1]].push_back(edge[0]);
        }

        while(!q.empty()){
            pair&lt;int, int&gt; cur = q.front();
            q.pop();
            int node = cur.first;
            int currentTime = cur.second;
            //找下一个节点
            for(int next : grid[node]){
                if(next == n){
                    if(first == -1){
                        first = currentTime + time;
                    }
                    else{
                        if(currentTime + time &gt; first) return currentTime + time;
                    }
                }

                int targetTime = currentTime + time;
                if((targetTime / change) % 2 == 1){
                    targetTime = (targetTime / change + 1) * change;
                }
                //如果已经达到该节点，一个节点经过两次，那么就不放进去，交给下面处理
                if(fast.find(next) == fast.end()){
                    fast[next] = targetTime;
                    q.push({next, targetTime});
                    continue;
                }
                //如果第二次达到该节点，并且用时比第一次还大，那么就放入
                if(second.find(next) == second.end() &amp;&amp; fast[next] &lt; targetTime){
                    second[next] = targetTime;
                    q.push({next, targetTime});
                    continue;
                }
            }  
        }
        return -1;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="第264场周赛"><a href="#第264场周赛" class="headerlink" title="第264场周赛"></a>第264场周赛</h2><p>这次周赛感觉是我做的最失败的一次了，第一题做了快一个小时，完全不在状态啊。</p>
<h3 id="5906-句子中的有效单词数"><a href="#5906-句子中的有效单词数" class="headerlink" title="5906. 句子中的有效单词数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/">5906. 句子中的有效单词数</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211024133644250.png" alt="image-20211024133644250" style="zoom:80%;">

<p>这题就是一个普通的模拟，不知道为什么做了这么长时间。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int countValidWords(string s) {
        int n = s.size();
        int count = 0;
        int cnt = 0;
        int cnt_ = 0;
        bool flag = true;

        for(int i = 0; i &lt; n;){
            cnt = 0;
            cnt_ = 0;
            flag = true;
            while(i &lt; n &amp;&amp; s[i] == ' ') i++;
            while(i &lt; n &amp;&amp; s[i] != ' '){
                //cout&lt;&lt;s[i]&lt;&lt;" ";
                if('0' &lt;= s[i] &amp;&amp; s[i] &lt;= '9'){
                    flag = false;
                    while(i &lt; n &amp;&amp; s[i] != ' ') i++;
                    break;
                }
                if(s[i] == '-'){
                    cnt_++;
                    if(cnt_ &gt; 1 || i == 0 || i == n - 1 || s[i - 1] &lt; 'a' || s[i - 1] &gt; 'z' || s[i + 1] &lt; 'a' || s[i + 1] &gt; 'z'){
                        flag = false;
                        while(i &lt; n &amp;&amp; s[i] != ' ') i++;
                        break;
                    }
                }
                if(s[i] == '.' || s[i] == ',' || s[i] == '!'){
                    cnt++;
                    if(cnt &gt; 1 || (i != n - 1 &amp;&amp; s[i + 1] != ' ')){
                        flag = false;
                        while(i &lt; n &amp;&amp; s[i] != ' ') i++;
                        break;
                    }
                }
                i++;
            }
            if(flag) {
                if(i == n &amp;&amp; s[i - 1] == ' ') continue;
                //cout&lt;&lt;s[i - 2]&lt;&lt;endl;
                count++;  
            }
        }
        return count;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>感觉先把字符串给分割开，再进行验证容易很多。</p>
<blockquote>
<p>isalpha()这个是用来判断是否是英文字母的，是的返回true，否则返回false</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int countValidWords(string sentence) {
        int n = sentence.size();
        vector&lt;string&gt; words;
        for(int i = 0; i &lt; n;){
            while(i &lt; n &amp;&amp; sentence[i] == ' ') i++;
            string s = "";
            while(i &lt; n &amp;&amp; sentence[i] != ' ') s += sentence[i++];
            words.push_back(s);
            while(i &lt; n &amp;&amp; sentence[i] == ' ') i++;
        }
        int ans = 0;
        for(string s : words){
            //cout&lt;&lt;s&lt;&lt;endl;
            //判断该字符串是否为单词
            bool flag = true;
            int m = s.size();
            for(int i = 0, cnt = 0; i &lt; m; i++){
                if('0' &lt;= s[i] &amp;&amp; s[i] &lt;= '9'){
                    flag = false;
                    break;
                }
                if(s[i] == '-'){
                    cnt++;
                    if(cnt &gt; 1 || i == 0 || i == m - 1 || !isalpha(s[i-1]) || !isalpha(s[i+1])){
                        flag = false;
                        break;
                    }
                }
                if(s[i] == '.' || s[i] == ',' || s[i] == '!'){
                    if(i != m - 1){
                        flag = false;
                        break;
                    }
                }
            }
            if(flag) ans++;
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5907-下一个更大的数值平衡数"><a href="#5907-下一个更大的数值平衡数" class="headerlink" title="5907. 下一个更大的数值平衡数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-numerically-balanced-number/">5907. 下一个更大的数值平衡数</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211024140004017.png" alt="image-20211024140004017" style="zoom:80%;">

<p>对于这一题我就是个纯憨批，太憨了😓我。直接打表就行了啊，非要模拟一半天。</p>
<p>可以用下面的函数进行打印符合要求的数字</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int cnt[10];
    int nextBeautifulNumber(int n) {
        vector&lt;int&gt; res;
        for(int i = 0; i &lt; MAXN; i++){
            if(check(i)) res.push_back(i);
        }
        printf("int men[%d] = {", res.size());
        for(int v : res) printf("%d, ", v);
        printf("}");
        return 0;
    }
    bool check(int x){
        memset(cnt, 0, sizeof(cnt));
        while(x){
            cnt[x % 10]++;
            x /= 10;
        }
        for(int i = 0; i &lt; 10; i++){
            if(cnt[i] &gt; 0 &amp;&amp; cnt[i] != i) return false; 
        }
        return true;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>得到了下面这些数字：我们可以用vector来进行装入。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">0, 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>最后提交的代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; mem{0, 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444};
class Solution {
public:
    int nextBeautifulNumber(int n) {
        return *upper_bound(mem.begin(), mem.end(), n);
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5908-统计最高分的节点数目"><a href="#5908-统计最高分的节点数目" class="headerlink" title="5908. 统计最高分的节点数目"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/">5908. 统计最高分的节点数目</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211024142634211.png" alt="image-20211024142634211" style="zoom:80%;">

<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211024142656286.png" alt="image-20211024142656286" style="zoom:80%;">

<p>这道题其实就是统计每个子树的大小，某节点的得分就是左右子树的大小以及父节点所在的树减去该节点所在的树的大小，这三个大小相乘。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LL long long
const int MAXN = 1e5 + 1;
int sz[MAXN];
class Solution {
public:
    vector&lt;int&gt; edges[MAXN];
    LL ans = 0; //防止相乘的时候溢出
    int cnt = 0;
    int tot;
    int countHighestScoreNodes(vector&lt;int&gt;&amp; parents) {
        int n = parents.size();
        tot = n;
        //清空
        for(int i = 0; i &lt; n; i++) edges[i].clear();
        //找到父节点对应的子节点
        for(int i = 1; i &lt; n; i++){
            edges[parents[i]].push_back(i);
        }
        dfs(0);
        return cnt;
    }
    void dfs(int x){
        LL cur = 1;
        sz[x] = 1;
        for(int edge : edges[x]){
            dfs(edge);
            sz[x] += sz[edge];
            cur = cur * sz[edge];
        }
        //父节点的树大小可直接用n减去该节点树的大小即可
        if(sz[x] &lt; tot) cur = cur * (tot - sz[x]);
        if(ans &lt; cur){
            ans = cur;
            cnt = 0;
        }
        if(ans == cur){
            cnt += 1;
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5909-并行课程-III"><a href="#5909-并行课程-III" class="headerlink" title="5909. 并行课程 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/parallel-courses-iii/">5909. 并行课程 III</a></h3><img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211024151648556.png" alt="image-20211024151648556" style="zoom:80%;">

<img src="C:\Users\王正宇\AppData\Roaming\Typora\typora-user-images\image-20211024151706206.png" alt="image-20211024151706206" style="zoom:80%;">

<p>这是一道典型的拓扑排序的题，不过我还是没看出来，太菜了主要是，但是理解了是拓扑排序的思路之后就不算很难了。</p>
<p>因为是可以同时上任意门课程，所以肯定是没有先行课的赶紧上，这样后面需要先行课的课才能及时的上。所以我们只需统计每门课的最早上课时间就行了，最后在统计记录最后一门课完成的时间。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int MAXN = 5e4 + 1;
vector&lt;int&gt; edges[MAXN];
int indeg[MAXN];
int dp[MAXN];
class Solution {
public:
    int minimumTime(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relations, vector&lt;int&gt;&amp; time) {
        queue&lt;int&gt; q;
        //初始化
        for(int i = 0; i &lt;= n; i++){
            edges[i].clear();
            indeg[i] = 0;
            dp[i] = 0;
        }
        //建立邻接图和入度
        for(vector&lt;int&gt;&amp; v : relations){
            edges[v[0]].push_back(v[1]);
            indeg[v[1]]++;
        }
        for(int i = 0; i &lt;= n; i++){
            if(indeg[i] == 0) q.push(i);
        }
        while(!q.empty()){
            int cur = q.front(); q.pop();
            //去掉与这个节点相邻的边，并且相应的节点的入度减一
            for(int v : edges[cur]){
                //更新该节点v的课程开始的最早时间
                dp[v] = max(dp[v], dp[cur] + time[cur - 1]);
                indeg[v]--;
                if(indeg[v] == 0) q.push(v);
            }
        }
        int ans = 0;
        //最后一门课的结束时间就是所有课程完成的最早时间，因为可以同时上任意一门课程
        for(int i = 1; i &lt;= n; i++){
            ans = max(ans, dp[i] + time[i - 1]);
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="第265场周赛"><a href="#第265场周赛" class="headerlink" title="第265场周赛"></a>第265场周赛</h2><h3 id="5916-转化数字的最小运算数"><a href="#5916-转化数字的最小运算数" class="headerlink" title="5916. 转化数字的最小运算数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-operations-to-convert-number/">5916. 转化数字的最小运算数</a></h3><img src="images/数据结构和算法/image-20211031131814515.png" alt="image-20211031131814515" style="zoom:80%;">

<p>这题比赛时是知道肯定得暴力遍历，但大概算了下感觉可能会超时，所以就想肯定有其它好的方法，所以导致一直没写出来。</p>
<p>其实这道题就是求最短路问题，还是单源无权最短路问题。start为起点，goal为终点，x + - ^nums[i]这些操作为边。</p>
<p>我们先把1000以内的点的情况都算了出来，1000以外的我们可以直接用终点来操作nums[i]，看看dist中有没有对应的情况。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int MAXN = 1e3 + 50;
int dist[MAXN];
class Solution {
public:
    int minimumOperations(vector&lt;int&gt;&amp; nums, int start, int goal) {
        //一道BFS的图论题，单源无权最短路问题。
        //我们可以把start看成起点，+、-、^nums[i]看成边
        memset(dist, -1, sizeof(dist));
        queue&lt;int&gt; q;
        q.push(start); dist[start] = 0;
        int n = nums.size();

        while(!q.empty()){
            int x = q.front(); q.pop();
            for(int i = 0; i &lt; n; i++){
                int v = nums[i], nv;
                
                nv = x - v;
                if(0 &lt;= nv &amp;&amp; nv &lt;= 1000 &amp;&amp; dist[nv] == -1){
                    dist[nv] = dist[x] + 1;
                    q.push(nv);
                }
                nv = x + v;
                if(0 &lt;= nv &amp;&amp; nv &lt;= 1000 &amp;&amp; dist[nv] == -1){
                    dist[nv] = dist[x] + 1;
                    q.push(nv);
                }
                nv = x ^ v;
                if(0 &lt;= nv &amp;&amp; nv &lt;= 1000 &amp;&amp; dist[nv] == -1){
                    dist[nv] = dist[x] + 1;
                    q.push(nv);
                }
            }
        }
        if(0 &lt;= goal &amp;&amp; goal &lt;= 1000) return dist[goal];
		//处理1000以外的
        int ans = -1;
        for(int i = 0; i &lt; n; i++){
            int v = nums[i], nv;
            
            nv = goal - v;
            if(0 &lt;= nv &amp;&amp; nv &lt;= 1000 &amp;&amp; dist[nv] != -1){
                if(ans == - 1 || ans &gt; dist[nv] + 1) ans = dist[nv] + 1;
            }
            nv = goal + v;
            if(0 &lt;= nv &amp;&amp; nv &lt;= 1000 &amp;&amp; dist[nv] != -1){
                if(ans == - 1 || ans &gt; dist[nv] + 1) ans = dist[nv] + 1;
            }
            nv = goal ^ v;
            if(0 &lt;= nv &amp;&amp; nv &lt;= 1000 &amp;&amp; dist[nv] != -1){
                if(ans == - 1 || ans &gt; dist[nv] + 1) ans = dist[nv] + 1;
            }
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第四题就不写了，因为真的不是人做的，看不懂真看不懂。先放着吧，等后面学得差不多了再回来看。</p>
<h2 id="第266场周赛"><a href="#第266场周赛" class="headerlink" title="第266场周赛"></a>第266场周赛</h2><p>这次周赛感觉第二题还是很简单的，但为什么自己没想出来呢/(ㄒoㄒ)/~~</p>
<h3 id="5919-所有子字符串中的元音"><a href="#5919-所有子字符串中的元音" class="headerlink" title="5919. 所有子字符串中的元音"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/vowels-of-all-substrings/">5919. 所有子字符串中的元音</a></h3><img src="images/数据结构和算法/image-20211107124825466.png" alt="image-20211107124825466" style="zoom:80%;">

<p>我们只需要遍历一遍，然后找元音字母，统计其左右两边情况即可，确实感觉比第一题还简单啊。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LL long long
class Solution {
public:
    long long countVowels(string word) {
        int n = word.size();
        LL ans = 0;
        char s[5] = {'a', 'e', 'i', 'o', 'u'};
        for(int i = 0; i &lt; n; i++){
            for(int k = 0; k &lt; 5; k++){
                if(word[i] == s[k]){
                    ans = ans + 1LL * (i + 1) * (n - i);
                }
            }
        }     
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5920-分配给商店的最多商品的最小值"><a href="#5920-分配给商店的最多商品的最小值" class="headerlink" title="5920. 分配给商店的最多商品的最小值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimized-maximum-of-products-distributed-to-any-store/">5920. 分配给商店的最多商品的最小值</a></h3><img src="images/数据结构和算法/image-20211107125157749.png" alt="image-20211107125157749" style="zoom:80%;">

<p><strong>像这种最大值最小就是经典的二分查找套路题，一定要记住熟悉啊</strong></p>
<p>套路题，我们可以采用二分来不断的尝试最小的最大。就是我们每次可以尝试分配每个商店最多mid个商品，所以我们遍历玩所有种类的商品后，如果还有店没有分配，那意味着我们可以尝试更小的限制值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    //套路题，我们可以采用二分来不断的尝试最小的最大值
    //就是我们每次可以尝试分配每个商店最多mid个商品，所以我们遍历玩所有种类的商品后，如果还有店没有分配，那意味着我们可以尝试更小的限制值
    bool check(int mid, vector&lt;int&gt;&amp; quantities, int n, int m){
        for(int i = 0; i &lt; m; i++){
            int v = quantities[i];
            int c = v / mid + (v %  mid == 0 ? 0 : 1);
            n -= c;
        }
        return n &gt;= 0;
    }
    int minimizedMaximum(int n, vector&lt;int&gt;&amp; quantities) {
        int m = quantities.size();
        int ans = 1e5;
        int left = 1, right = 1e5;
        while(left &lt;= right){
            int mid = left + (right - left) / 2;
            if(check(mid, quantities, n, m)){
                ans = min(ans, mid);
                //尝试更小的值
                right = mid - 1;
            }
            else{
                //这个不行，得分配更多一点
                left = mid + 1;
            }
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5921-最大化一张图中的路径价值"><a href="#5921-最大化一张图中的路径价值" class="headerlink" title="5921. 最大化一张图中的路径价值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-path-quality-of-a-graph/">5921. 最大化一张图中的路径价值</a></h3><img src="images/数据结构和算法/image-20211107144851338.png" alt="image-20211107144851338" style="zoom:80%;">

<p>这题还是挺简单的，就是暴力搜索路径，因为它限制了time和maxTime都小于100大于10，那说明最多走10条边，那么随便暴力搜就完事了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define PII pair&lt;int, int&gt;
const int MAXN = 1e3 + 50;
vector&lt;PII&gt;edge[MAXN];
bool vis[MAXN];
class Solution {
public:
    int ans = 0;
    void dfs(int x, int value, int remain, vector&lt;int&gt;&amp; values){
        bool vist = vis[x];
        if(!vis[x]){
            value = value + values[x];
            vis[x] = true;
        }
        if(x == 0){
            ans = max(ans, value);
        }
        for(auto&amp; e : edge[x]){
            int v = e.first, t = e.second;
            if(t &lt;= remain){
                dfs(v, value, remain - t, values);
            }
        }
        vis[x] = vist;
    }
    int maximalPathQuality(vector&lt;int&gt;&amp; values, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxTime) {
        int n = values.size();
        for(int i = 0; i &lt;= n; i++){
            edge[i].clear();
            vis[i] = false;
        }
        for(vector&lt;int&gt;&amp; e : edges){
            edge[e[0]].push_back({e[1], e[2]});
            edge[e[1]].push_back({e[0], e[2]});
        }
        ans = 0;
        dfs(0, 0, maxTime, values);
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="第267场周赛"><a href="#第267场周赛" class="headerlink" title="第267场周赛"></a>第267场周赛</h2><p>这次周赛还算可以，不过还是很大的失误啊，wrong了3次，浪费了不少时间。最后一题当时也知道是并查集，但就是不知道怎么用，还是对并查集理解不到位啊。</p>
<h3 id="5929-处理含限制条件的好友请求"><a href="#5929-处理含限制条件的好友请求" class="headerlink" title="5929. 处理含限制条件的好友请求"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/process-restricted-friend-requests/">5929. 处理含限制条件的好友请求</a></h3><img src="images/数据结构和算法/image-20211114125259152.png" alt="image-20211114125259152" style="zoom:80%;">

<p>这题其实就是对每一个请求遍历一遍限制，看是否在这两个连通分量里面。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int MAXN = 1e3 + 50;
int fa[MAXN];

int getFather(int x){
    while(x != fa[x]){
        fa[x] = fa[fa[x]];
        x = fa[x];
    }
    return x;
}
class Solution {
public:
    vector&lt;bool&gt; friendRequests(int n, vector&lt;vector&lt;int&gt;&gt;&amp; restrictions, vector&lt;vector&lt;int&gt;&gt;&amp; requests) {
        memset(fa, 0, sizeof(fa));
        for(int i = 0; i &lt;= n; i++) fa[i] = i;
        vector&lt;bool&gt; ans;
        for(auto&amp; r : requests){
            int u = r[0], v = r[1];
            int fu = getFather(u), fv = getFather(v);
            if(fu == fv) ans.push_back(true);
            else{
                bool flag = true;
                for(auto&amp; r : restrictions){
                    int x = r[0], y = r[1];
                    int fx = getFather(x), fy = getFather(y);
                    if(fx == fu &amp;&amp; fy == fv) flag = false;
                    if(fx == fv &amp;&amp; fy == fu) flag = false;
                    if(!flag) break;
                }
                if(flag) fa[fu] = fv;
                ans.push_back(flag);
            }
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="第268场周赛"><a href="#第268场周赛" class="headerlink" title="第268场周赛"></a>第268场周赛</h2><p>这次周赛应该还是挺简单的，但是脑袋没转过来。</p>
<h3 id="5186-区间内查询数字的频率"><a href="#5186-区间内查询数字的频率" class="headerlink" title="5186. 区间内查询数字的频率"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-frequency-queries/">5186. 区间内查询数字的频率</a></h3><img src="images/数据结构和算法/image-20211121121425235.png" alt="image-20211121121425235" style="zoom:80%;">

<p>这题卡了我好久，都到最后一个样例了，一直卡着，难受啊。</p>
<p>这题用二分查找就行了。我们可以存储每个元素出现的下标，然后利用二分查找，找到刚好大于right的迭代器，和刚好大于left- 1的迭代器，两者相减就行了。（注意这里不是该元素在元素组中的下标相减，而是在哈希表的vector中的下标相减）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class RangeFreqQuery {
public:
    unordered_map&lt;int, vector&lt;int&gt;&gt; res;
    RangeFreqQuery(vector&lt;int&gt;&amp; arr) {
        for(int i = 0; i &lt; arr.size(); i++){
            res[arr[i]].emplace_back(i);
        }
    }
    
    int query(int left, int right, int value) {
        if(res.count(value) == 0){
            return 0;
        }
        auto&amp; ans = res[value];
        auto l = upper_bound(ans.begin(), ans.end(), left - 1);
        auto r = upper_bound(ans.begin(), ans.end(), right);
        return r - l;
    }
};

/**
 * Your RangeFreqQuery object will be instantiated and called as such:
 * RangeFreqQuery* obj = new RangeFreqQuery(arr);
 * int param_1 = obj-&gt;query(left,right,value);
 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5933-k-镜像数字的和"><a href="#5933-k-镜像数字的和" class="headerlink" title="5933. k 镜像数字的和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-k-mirror-numbers/">5933. k 镜像数字的和</a></h3><img src="images/数据结构和算法/image-20211121133852006.png" alt="image-20211121133852006" style="zoom:80%;">

<p>这道题就是三道思路的组合：</p>
<ol>
<li>已知一个十进制对称数，求下一个十进制对称数</li>
<li>判断一个字符串是否对称</li>
<li>将十进制转换成k进制字符串</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef long long LL;
LL nextLL(LL num){
    bool longer = true;
    string s = to_string(num);
    int len = s.size();
    LL ans = 0;
    // 因为是对称的，所以取一半就行
    // 我们可以从最中间开始，如果可以加一，那么就加，否则就下一个
    for(int i = len / 2; i &gt;= 0; i--){
        if(s[i] != '9'){
            s[i]++;
            //这个是防止同一个位置加了两次，其实就是防止奇数个字符时中间加了两次
            if(len - 1 - i != i){
                s[len - 1 - i]++;
            }
            //后面都要全部取0
            for(int j = i + 1; j &lt;= len / 2; j++){
                s[j] = '0';
                s[len - 1 - j] = '0';
            }
            longer = false;
            break;
        }
    }
    //如果全都是9的话，那么就要左右加1个‘1’，然后其它位都为0
    if(longer){
    ans = 1;
    for(int i = 0; i &lt; len; i++){
            ans *= 10;
        }
        ans += 1;
    }
    else{
        //stoll()是把字符串转化成LL类型
        ans = stoll(s);
    }
    return ans;
}
//这里如果没有&amp;，那么内存会多消耗1倍，时间也会增加，所以以后传入字符串最好是传d
bool isSymmetric(string&amp; s){
    int len = s.size();
    for(int i = len / 2; i &gt;= 0; i--){
        if(s[i] != s[len - i - 1]){
            return false;
        }
    }
    return true;
}
string toKString(LL num, int k){
    string s = "";
    while(num){
        s +=  (char)(num % k + '0');
        num /= k;
    }
    return s;
}
class Solution {
public:
    LL kMirror(int k, int n) {
        LL ans = 0;
        LL num = 0;
        while(n){
            num = nextLL(num);
            string s = toKString(num, k);
            if(isSymmetric(s)){
                n--;
                ans += num;
            }
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="第269场周赛"><a href="#第269场周赛" class="headerlink" title="第269场周赛"></a>第269场周赛</h2><p>这场周赛除了第四题外竟然异常的顺利，这次竞赛积分也终于上了1600，改往1700努力了。感觉想要进排名前500，第四题必须得拿下啊。</p>
<h3 id="5941-找出知晓秘密的所有专家"><a href="#5941-找出知晓秘密的所有专家" class="headerlink" title="5941. 找出知晓秘密的所有专家"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-people-with-secret/">5941. 找出知晓秘密的所有专家</a></h3><img src="images/数据结构和算法/image-20211128125555403.png" alt="image-20211128125555403" style="zoom:80%;">

<p>这题就是并查集模板题，但是要涉及到恢复已连接的边，我们可以使用队列来记录。</p>
<p>我们还是要处理同一时刻的那些点，但是还有个问题，同一时刻的点有的不在知晓秘密的那个连通分量里面，所以我们可以每次连通两个点时，把父节点较大的那个连接在父节点较小的那个点下，这样就可以保证0时所有知晓秘密的祖宗节点。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int MAXN = 1e5 + 50;

int fa[MAXN];
queue&lt;int&gt; q;

int getFather(int x){
    return fa[x] = (fa[x] == x ? x : getFather(fa[x]));
}
void mergeFather(int x, int y){
    int fx = getFather(x), fy = getFather(y);
    if(fx == fy) return;
    //保证较大的放在较小的后面，确保了0是祖宗节点
    if(fx &gt; fy) swap(fx, fy);
    fa[fy] = fx;
}
class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        sort(meetings.begin(), meetings.end(), [&amp;](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b){
            return a[2] &lt; b[2];
        });
        for(int i = 0; i &lt; n; i++) fa[i] = i;
        mergeFather(0, firstPerson);
        vector&lt;int&gt; ans;
        int m = meetings.size();
        for(int i = 0, j = 0; i &lt; m; i = j){
            while(j &lt; m &amp;&amp; meetings[i][2] == meetings[j][2]){
                mergeFather(meetings[j][0], meetings[j][1]);
                q.push(meetings[j][0]);
                q.push(meetings[j][1]);
                j++;
            }
            //恢复不知晓秘密的点
            while(!q.empty()){
                int x = q.front(); q.pop();
                int fx = getFather(x);
                if(fx == 0){
					//o
                }else fa[x] = x;
            }
        }
        for(int i = 0; i &lt; n; i++){
            if(getFather(i) == 0){
                ans.push_back(i);
            }
        }
        return ans;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">老王</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://1414521825.github.io/2021/12/01/shu-ju-jie-gou-he-suan-fa/shu-ju-jie-gou-he-suan-fa/">http://1414521825.github.io/2021/12/01/shu-ju-jie-gou-he-suan-fa/shu-ju-jie-gou-he-suan-fa/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint policy. If reproduced, please indicate source
                    <a href="/about" target="_blank">老王</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;Current
            </div>
            <div class="card">
                <a href="/2021/12/01/shu-ju-jie-gou-he-suan-fa/shu-ju-jie-gou-he-suan-fa/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-12-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            老王
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/11/22/hello-world/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Hello World">
                        
                        <span class="card-title">Hello World</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            老王
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021</span>
            
            <a href="/about" target="_blank">老王</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;Total Words:&nbsp;<span
                        class="white-color">50.3k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;Total visits:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;Total visitors:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2021";
                        var startMonth = "11";
                        var startDate = "23";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-cn';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/1414521825" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1414521825@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1414521825" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1414521825" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>

</html>
